This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-08T15:31:48.106Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  __mocks__/
    express.ts
    twitter-api-v2.ts
    winston.ts
  __tests__/
    schema.test.ts
    TwitterService.test.ts
    TwitterServiceLive.test.ts
  checkAuth.ts
  index.ts
  registerWebhook.ts
  testApi.ts
  testEndpoints.ts
  testTweet.ts
  types.ts
.env.example
.eslintrc.json
.gitignore
.prettierrc
jest.config.js
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/__mocks__/express.ts
================
import { Request, Response } from 'express';
import { EventEmitter } from 'events';

export interface MockResponse extends Partial<Response> {
  status: jest.Mock;
  send: jest.Mock;
  json: jest.Mock;
  end: jest.Mock;
  setHeader: jest.Mock;
  getHeader: jest.Mock;
}

export interface MockRequest extends Partial<Request> {
  body?: any;
  headers?: Record<string, string>;
  query?: Record<string, string>;
  params?: Record<string, string>;
}

export interface MockServer extends EventEmitter {
  on: jest.Mock;
  emit: jest.Mock;
  close: jest.Mock;
}

export interface MockApp {
  use: jest.Mock;
  post: jest.Mock;
  get: jest.Mock;
  listen: jest.Mock;
}

export interface MockExpress {
  (): MockApp;
  json: jest.Mock;
  urlencoded: jest.Mock;
  static: jest.Mock;
}

// Create mock response factory
const createMockResponse = (): MockResponse => {
  const res: MockResponse = {
    status: jest.fn().mockReturnThis(),
    send: jest.fn().mockReturnThis(),
    json: jest.fn().mockReturnThis(),
    end: jest.fn().mockReturnThis(),
    setHeader: jest.fn().mockReturnThis(),
    getHeader: jest.fn(),
  };
  return res;
};

// Create mock server factory with direct EventEmitter usage
const createMockServer = (): MockServer => {
  const server = new EventEmitter() as MockServer;
  server.on = jest.fn().mockImplementation((event: string, handler: (...args: any[]) => void) => {
    server.addListener(event, handler);
    return server;
  });
  server.emit = jest.fn().mockImplementation((event: string, ...args: any[]) => {
    return EventEmitter.prototype.emit.call(server, event, ...args);
  });
  server.close = jest.fn().mockImplementation((callback?: () => void) => {
    if (callback) callback();
    return server;
  });
  return server;
};

// Create mock app factory with enhanced functionality
const createMockApp = (server: MockServer): MockApp => ({
  use: jest.fn(),
  post: jest.fn(),
  get: jest.fn(),
  listen: jest.fn((port: number, cb?: () => void) => {
    if (cb) cb();
    return server;
  }),
});

// Create mock express factory with additional middleware support
const createMockExpress = (): MockExpress => {
  const mockServer = createMockServer();
  const mockApp = createMockApp(mockServer);
  
  const mockExpress = jest.fn(() => mockApp) as unknown as MockExpress;
  mockExpress.json = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.urlencoded = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.static = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  
  return mockExpress;
};

export default createMockExpress();

================
File: src/__mocks__/twitter-api-v2.ts
================
import { TwitterApi as RealTwitterApi } from 'twitter-api-v2';

export interface MockTwitterApiV2 {
  reply: jest.Mock;
  tweet: jest.Mock;
  userTimeline: jest.Mock;
  deleteTweet: jest.Mock;
  _prefix: string;
  readWrite: Record<string, unknown>;
  labs: Record<string, unknown>;
  readOnly: Record<string, unknown>;
}

export interface MockTwitterApi {
  v2: MockTwitterApiV2;
}

// Create mock Twitter API v2 instance
const createMockTwitterApiV2 = (): MockTwitterApiV2 => ({
  reply: jest.fn(),
  tweet: jest.fn(),
  userTimeline: jest.fn(),
  deleteTweet: jest.fn(),
  _prefix: '',
  readWrite: {},
  labs: {},
  readOnly: {},
});

// Create mock Twitter API factory
const createMockTwitterApi = () => {
  const mockTwitterApiV2 = createMockTwitterApiV2();
  const MockTwitterApi = jest.fn().mockImplementation(() => ({
    v2: mockTwitterApiV2,
    getErrors: jest.fn(),
    getProfileImageInSize: jest.fn(),
  }));

  return MockTwitterApi as unknown as jest.MockedClass<typeof RealTwitterApi>;
};

export const TwitterApi = createMockTwitterApi();

================
File: src/__mocks__/winston.ts
================
interface LogMethod {
  (message: string, ...meta: any[]): void;
  (info: object): void;
}

interface MockLogger {
  info: jest.Mock;
  error: jest.Mock;
  warn: jest.Mock;
  debug: jest.Mock;
  log: jest.Mock;
}

interface MockWinston {
  createLogger: jest.Mock;
  format: {
    combine: jest.Mock;
    timestamp: jest.Mock;
    printf: jest.Mock;
    colorize: jest.Mock;
  };
  transports: {
    Console: jest.Mock;
  };
}

// Create mock logger factory
const createMockLogger = (): MockLogger => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
  log: jest.fn(),
});

// Create mock winston instance
const mockWinston: MockWinston = {
  createLogger: jest.fn().mockReturnValue(createMockLogger()),
  format: {
    combine: jest.fn(),
    timestamp: jest.fn(),
    printf: jest.fn(),
    colorize: jest.fn(),
  },
  transports: {
    Console: jest.fn(),
  },
};

export = mockWinston;

================
File: src/__tests__/schema.test.ts
================
import { twitterWebhookSchema } from '../types';

describe('Twitter Webhook Schema', () => {
  describe('tweet events', () => {
    it('should validate a valid tweet webhook payload', () => {
      const validPayload = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          created_at: '2024-01-07T12:00:00Z',
          in_reply_to_user_id: 'user456',
        },
      };

      const result = twitterWebhookSchema.safeParse(validPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(validPayload);
        expect(result.data.tweet?.text).toBe('Hello, world!');
        expect(result.data.tweet?.author_id).toBe('user123');
      }
    });

    it('should validate a tweet with optional fields', () => {
      const tweetWithOptionals = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          referenced_tweets: [
            { type: 'replied_to', id: '987654321' },
          ],
          entities: {
            mentions: [{ username: 'test', id: 'user456' }],
          },
        },
      };

      const result = twitterWebhookSchema.safeParse(tweetWithOptionals);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.referenced_tweets).toBeDefined();
        expect(result.data.tweet?.entities?.mentions).toBeDefined();
      }
    });

    it('should validate a tweet with multiple referenced tweets', () => {
      const tweetWithMultipleRefs = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          referenced_tweets: [
            { type: 'replied_to', id: '987654321' },
            { type: 'quoted', id: '456789123' },
          ],
        },
      };

      const result = twitterWebhookSchema.safeParse(tweetWithMultipleRefs);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.referenced_tweets).toHaveLength(2);
      }
    });
  });

  describe('direct message events', () => {
    it('should validate a valid direct message event payload', () => {
      const validDirectMessagePayload = {
        direct_message_events: [{
          type: 'message_create',
          id: '123456789',
          message_create: {
            message_data: {
              text: 'Hello via DM',
              entities: {},
            },
            sender_id: 'sender123',
            target: {
              recipient_id: 'recipient456',
            },
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(validDirectMessagePayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(validDirectMessagePayload);
      }
    });

    it('should validate multiple direct message events', () => {
      const multipleDirectMessages = {
        direct_message_events: [
          {
            type: 'message_create',
            id: '123456789',
            message_create: {
              message_data: {
                text: 'First message',
                entities: {},
              },
              sender_id: 'sender123',
            },
          },
          {
            type: 'message_create',
            id: '987654321',
            message_create: {
              message_data: {
                text: 'Second message',
                entities: {},
              },
              sender_id: 'sender456',
            },
          },
        ],
      };

      const result = twitterWebhookSchema.safeParse(multipleDirectMessages);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.direct_message_events).toHaveLength(2);
      }
    });
  });

  describe('combined events', () => {
    it('should validate payload with both tweet and direct message events', () => {
      const combinedPayload = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
        },
        direct_message_events: [{
          type: 'message_create',
          id: '987654321',
          message_create: {
            message_data: {
              text: 'Hello via DM',
              entities: {},
            },
            sender_id: 'sender123',
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(combinedPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet).toBeDefined();
        expect(result.data.direct_message_events).toBeDefined();
      }
    });
  });

  describe('empty and missing fields', () => {
    it('should validate payload without any event object', () => {
      const emptyPayload = {};
      const result = twitterWebhookSchema.safeParse(emptyPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(emptyPayload);
      }
    });

    it('should validate payload with empty tweet object', () => {
      const emptyTweetPayload = {
        tweet: {
          text: '',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
        },
      };

      const result = twitterWebhookSchema.safeParse(emptyTweetPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.text).toBe('');
      }
    });

    it('should validate payload with empty direct message events array', () => {
      const emptyDMPayload = {
        direct_message_events: [],
      };

      const result = twitterWebhookSchema.safeParse(emptyDMPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.direct_message_events).toHaveLength(0);
      }
    });
  });

  describe('validation failures', () => {
    it('should fail validation for invalid tweet object structure', () => {
      const invalidPayload = {
        tweet: {
          // Missing required fields
          text: 'Hello, world!',
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidPayload);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues).toHaveLength(3); // Should have 3 missing field errors
        expect(result.error.issues[0].code).toBe('invalid_type');
      }
    });

    it('should fail validation for invalid field types', () => {
      const invalidTypes = {
        tweet: {
          text: 123, // Should be string
          id: 456, // Should be string
          conversation_id: true, // Should be string
          author_id: {}, // Should be string
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidTypes);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues).toHaveLength(4); // Should have 4 type errors
        expect(result.error.issues[0].code).toBe('invalid_type');
      }
    });

    it('should fail validation for invalid direct message structure', () => {
      const invalidDM = {
        direct_message_events: [{
          type: 'message_create',
          // Missing required fields
          message_create: {
            message_data: {
              // Missing text
            },
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(invalidDM);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues.length).toBeGreaterThan(0);
      }
    });

    it('should fail validation for invalid entities in tweet', () => {
      const invalidEntities = {
        tweet: {
          text: 'Hello',
          id: '123',
          conversation_id: 'conv123',
          author_id: 'user123',
          entities: {
            mentions: [
              { username: 123, id: true }, // Invalid types
            ],
          },
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidEntities);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues.length).toBeGreaterThan(0);
      }
    });
  });
});

================
File: src/__tests__/TwitterService.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi } from 'twitter-api-v2';
import express from 'express';
import { MockApp, MockServer, MockRequest, MockResponse } from '../__mocks__/express';
import { MockTwitterApiV2 } from '../__mocks__/twitter-api-v2';
import mockExpress from '../__mocks__/express';

jest.mock('express');
jest.mock('twitter-api-v2');
jest.mock('winston');

const MockedTwitterApi = jest.mocked(TwitterApi);
const MockedExpress = jest.mocked(express);

describe('TwitterService', () => {
  let service: TwitterService;
  let mockApp: MockApp;
  let mockServer: MockServer;
  let mockTwitterApiV2: MockTwitterApiV2;
  
  const mockConfig: TwitterServiceConfig = {
    apiKey: 'test-key',
    apiSecret: 'test-secret',
    webhookPort: 3000,
    threadHistoryLimit: 50,
  };

  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    
    // Setup express mocks
    mockServer = {
      on: jest.fn(),
      emit: jest.fn(),
      close: jest.fn(),
      addListener: jest.fn(),
      once: jest.fn(),
      prependListener: jest.fn(),
      prependOnceListener: jest.fn(),
      removeListener: jest.fn(),
      removeAllListeners: jest.fn(),
      setMaxListeners: jest.fn(),
      getMaxListeners: jest.fn(),
      listeners: jest.fn(),
      rawListeners: jest.fn(),
      listenerCount: jest.fn(),
      eventNames: jest.fn(),
    } as unknown as MockServer;
    
    mockApp = {
      use: jest.fn(),
      post: jest.fn(),
      get: jest.fn(),
      listen: jest.fn().mockImplementation((port: number, cb?: () => void) => {
        if (cb) cb();
        return mockServer;
      }),
    };
    (MockedExpress as any).mockReturnValue(mockApp);
    
    // Setup Twitter API mock with full interface implementation
    mockTwitterApiV2 = {
      reply: jest.fn(),
      tweet: jest.fn(),
      userTimeline: jest.fn(),
      deleteTweet: jest.fn(),
      _prefix: '',
      readWrite: {},
      labs: {},
      readOnly: {},
    };
    
    const mockTwitterApi = {
      v2: mockTwitterApiV2,
      v1: {},
      readWrite: {},
      readOnly: {},
      currentUser: () => Promise.resolve({}),
      currentUserV2: () => Promise.resolve({}),
      login: jest.fn(),
      logout: jest.fn(),
      generateAuthLink: jest.fn(),
      generateOAuth2AuthLink: jest.fn(),
      refreshOAuth2AccessToken: jest.fn(),
      revokeOAuth2AccessToken: jest.fn(),
      clientId: '',
      clientSecret: '',
      basicToken: '',
      bearerToken: '',
      accessToken: '',
      accessSecret: '',
      scope: [],
      requestClient: {} as any,
      appLogin: jest.fn(),
      loginWithOAuth2: jest.fn(),
      search: jest.fn(),
    } as unknown as TwitterApi;
    
    MockedTwitterApi.mockImplementation(() => mockTwitterApi);
    
    service = new TwitterService(mockConfig);
  });

  describe('constructor', () => {
    it('should create instance with API key/secret', () => {
      expect(service).toBeInstanceOf(TwitterService);
      expect(MockedTwitterApi).toHaveBeenCalledWith({
        appKey: mockConfig.apiKey,
        appSecret: mockConfig.apiSecret,
      });
    });

    it('should create instance with bearer token', () => {
      const configWithBearer = {
        ...mockConfig,
        bearerToken: 'test-bearer-token',
      };
      const service = new TwitterService(configWithBearer);
      expect(service).toBeInstanceOf(TwitterService);
      expect(MockedTwitterApi).toHaveBeenCalledWith(configWithBearer.bearerToken);
    });

    it('should use default thread history limit if not provided', async () => {
      const service = new TwitterService({
        ...mockConfig,
        threadHistoryLimit: undefined,
      });
      const threadId = 'test-thread';
      const messages = Array.from({ length: 51 }, (_, i) => ({
        senderId: 'user1',
        timestamp: i,
        content: `message ${i}`,
      }));

      // Add messages one by one to ensure they are processed in order
      for (const msg of messages) {
        service['addMessageToThread'](threadId, msg);
      }

      // Get the context after all messages are added
      const context = service['getThreadContext'](threadId);
      
      // Should keep the most recent 50 messages
      expect(context.history).toHaveLength(50);
      // Should have messages 1-50 (not 0-49)
      expect(context.history[0].content).toBe('message 1');
      expect(context.history[49].content).toBe('message 50');
      // Verify messages are in order
      const contents = context.history.map(msg => msg.content);
      expect(contents).toEqual(messages.slice(1).map(msg => msg.content));
    });
  });

  describe('server initialization', () => {
    let mockExpressApp: MockApp;

    beforeEach(() => {
      // Reset express mock for each test
      jest.clearAllMocks();

      // Create a new mock server for each test
      mockServer = {
        on: jest.fn(),
        emit: jest.fn(),
        close: jest.fn(),
        addListener: jest.fn(),
        once: jest.fn(),
        prependListener: jest.fn(),
        prependOnceListener: jest.fn(),
        removeListener: jest.fn(),
        removeAllListeners: jest.fn(),
        setMaxListeners: jest.fn(),
        getMaxListeners: jest.fn(),
        listeners: jest.fn(),
        rawListeners: jest.fn(),
        listenerCount: jest.fn(),
        eventNames: jest.fn(),
      } as unknown as MockServer;

      // Create a new mock app for each test
      mockExpressApp = {
        use: jest.fn(),
        post: jest.fn(),
        get: jest.fn(),
        listen: jest.fn().mockImplementation((port: number, cb?: () => void) => {
          if (cb) cb();
          return mockServer;
        }),
      };

      // Setup the express mock
      (MockedExpress as any).mockReturnValue(mockExpressApp);
      (express.json as jest.Mock).mockReturnValue(jest.fn());

      // Create a new service instance
      service = new TwitterService(mockConfig);
    });

    it('should start server successfully', async () => {
      await service.start();
      expect(mockExpressApp.listen).toHaveBeenCalledWith(mockConfig.webhookPort, expect.any(Function));
    });

    it('should handle server startup error', async () => {
      const mockError = new Error('Server startup failed');
      mockServer.on.mockImplementation((event: string, handler: (error: Error) => void) => {
        if (event === 'error') {
          handler(mockError);
        }
      });

      const mockEmit = jest.spyOn(service, 'emit');
      await service.start();

      expect(mockServer.on).toHaveBeenCalledWith('error', expect.any(Function));
      expect(mockEmit).toHaveBeenCalledWith('serverError', mockError);
    });

    it('should handle express middleware error', async () => {
      const mockError = new Error('Middleware error');
      (express.json as jest.Mock).mockImplementation(() => {
        throw mockError;
      });

      await expect(service.start()).rejects.toThrow(mockError);
    });

    it('should handle port already in use error', async () => {
      const mockError = new Error('EADDRINUSE');
      mockServer.on.mockImplementation((event: string, handler: (error: Error) => void) => {
        if (event === 'error') {
          handler(mockError);
        }
      });

      const mockEmit = jest.spyOn(service, 'emit');
      await service.start();

      expect(mockServer.on).toHaveBeenCalledWith('error', expect.any(Function));
      expect(mockEmit).toHaveBeenCalledWith('serverError', mockError);
    });
  });

  describe('webhook handling', () => {
    it('should handle webhook processing error', async () => {
      const mockReq = {
        body: { invalid: 'data' },
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
    });

    it('should process valid webhook data', async () => {
      const validMention = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
        },
      };

      const mockReq = {
        body: validMention,
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };
      const mockEmit = jest.spyOn(service, 'emit');

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
      expect(mockEmit).toHaveBeenCalledWith('newMention', expect.any(Object));
    });

    it('should handle malformed JSON in webhook request', async () => {
      const mockReq = {
        body: undefined,
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };
      const mockEmit = jest.spyOn(service, 'emit');

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
      expect(mockEmit).not.toHaveBeenCalledWith('newMention', expect.any(Object));
    });
  });

  describe('event handling', () => {
    it('should emit newMention event when valid mention is received', (done) => {
      const validMention = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
        },
      };

      service.on('newMention', (event: MentionEvent) => {
        expect(event).toEqual({
          message: validMention.tweet.text,
          threadId: validMention.tweet.conversation_id,
          userId: validMention.tweet.author_id,
          tweetId: validMention.tweet.id,
        });
        done();
      });

      service['handleMention'](validMention);
    });

    it('should not emit newMention event for invalid mention', () => {
      const invalidMention = {
        not_a_tweet: {},
      };

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](invalidMention);

      expect(mockEmit).not.toHaveBeenCalledWith('newMention', expect.any(Object));
    });

    it('should handle mentions with referenced tweets', () => {
      const mentionWithRefs = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
          referenced_tweets: [
            { type: 'replied_to', id: 'original-tweet' },
          ],
        },
      };

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](mentionWithRefs);

      expect(mockEmit).toHaveBeenCalledWith('newMention', expect.any(Object));
    });
  });

  describe('thread context', () => {
    it('should maintain thread history', () => {
      const threadId = 'test-thread';
      const message = {
        senderId: 'user1',
        timestamp: Date.now(),
        content: 'test message',
      };

      service['addMessageToThread'](threadId, message);
      const context = service['getThreadContext'](threadId);

      expect(context.threadId).toBe(threadId);
      expect(context.history).toHaveLength(1);
      expect(context.history[0]).toEqual(message);
    });

    it('should respect thread history limit', () => {
      const configWithLimit = {
        ...mockConfig,
        threadHistoryLimit: 2,
      };
      const service = new TwitterService(configWithLimit);
      const threadId = 'test-thread';

      const messages = [
        { senderId: 'user1', timestamp: 1, content: 'message 1' },
        { senderId: 'user1', timestamp: 2, content: 'message 2' },
        { senderId: 'user1', timestamp: 3, content: 'message 3' },
      ];

      messages.forEach(msg => service['addMessageToThread'](threadId, msg));
      const context = service['getThreadContext'](threadId);

      expect(context.history).toHaveLength(2);
      expect(context.history).toEqual([messages[1], messages[2]]);
    });

    it('should handle concurrent thread updates', async () => {
      const service = new TwitterService({
        ...mockConfig,
        threadHistoryLimit: 50,
      });
      const threadId = 'test-thread';
      const messages = Array.from({ length: 100 }, (_, i) => ({
        senderId: 'user1',
        timestamp: i,
        content: `message ${i}`,
      }));

      // Simulate concurrent updates
      await Promise.all(messages.map(msg => 
        Promise.resolve().then(() => service['addMessageToThread'](threadId, msg))
      ));

      const context = service['getThreadContext'](threadId);
      
      // Should respect the default limit of 50
      expect(context.history).toHaveLength(50);
      
      // Verify messages are in chronological order
      const timestamps = context.history.map(msg => msg.timestamp);
      const sortedTimestamps = [...timestamps].sort((a, b) => a - b);
      expect(timestamps).toEqual(sortedTimestamps);
      
      // Verify we have the last 50 messages
      expect(timestamps[0]).toBe(50); // Should start at message 50
      expect(timestamps[49]).toBe(99); // Should end at message 99
    });

    it('should handle multiple threads independently', () => {
      const thread1 = 'thread-1';
      const thread2 = 'thread-2';

      const message1 = { senderId: 'user1', timestamp: 1, content: 'thread 1 message' };
      const message2 = { senderId: 'user2', timestamp: 2, content: 'thread 2 message' };

      service['addMessageToThread'](thread1, message1);
      service['addMessageToThread'](thread2, message2);

      const context1 = service['getThreadContext'](thread1);
      const context2 = service['getThreadContext'](thread2);

      expect(context1.history[0]).toEqual(message1);
      expect(context2.history[0]).toEqual(message2);
    });
  });

  describe('error handling', () => {
    it('should emit rateLimitWarning when rate limited', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('Rate limit exceeded');
      (mockError as any).rateLimitError = true;

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      const serviceWithMock = new TwitterService(mockConfig);
      const mockEmit = jest.spyOn(serviceWithMock, 'emit');

      try {
        await serviceWithMock['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('rateLimitWarning', {
        tweetId,
        message,
        error: mockError,
      });
    });

    it('should handle successful tweet reply', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockResponse = { data: { id: 'reply-id' } };

      mockTwitterApiV2.reply.mockResolvedValueOnce(mockResponse);

      const response = await service['replyToTweet'](tweetId, message);
      expect(response).toEqual(mockResponse);
      expect(mockTwitterApiV2.reply).toHaveBeenCalledWith(message, tweetId);
    });

    it('should emit tweetError for non-rate-limit errors', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('API error');

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      const mockEmit = jest.spyOn(service, 'emit');

      try {
        await service['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('tweetError', {
        tweetId,
        message,
        error: mockError,
      });
    });

    it('should handle network errors during tweet reply', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('Network error');
      mockError.name = 'NetworkError';

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);
      const mockEmit = jest.spyOn(service, 'emit');

      try {
        await service['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('tweetError', {
        tweetId,
        message,
        error: mockError,
      });
    });
  });

  describe('Logging', () => {
    let mockLogger: any;
    
    beforeEach(() => {
      // Get the mock logger instance
      mockLogger = require('winston').createLogger();
      
      // Mock the error method to capture meta objects
      mockLogger.error.mockImplementation((message: string, meta?: any) => {
        if (meta?.error instanceof Error) {
          return { message, meta };
        }
      });
      
      // Mock the warn method to capture meta objects
      mockLogger.warn.mockImplementation((message: string, meta?: any) => {
        if (meta?.error instanceof Error) {
          return { message, meta };
        }
      });
    });

    it('should log server start', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.stringContaining('Server is running on port 3000')
      );
    });

    it('should log webhook events', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      
      // Simulate webhook event
      const mockWebhookData = {
        for_user_id: '123',
        tweet_create_events: [{
          id_str: '456',
          user: { id_str: '789' },
          text: 'test tweet'
        }]
      };

      // Get the post handler
      const postHandler = (mockExpress().post as jest.Mock).mock.calls[0][1];
      await postHandler({ body: mockWebhookData }, { status: jest.fn().mockReturnThis(), send: jest.fn() });

      expect(mockLogger.info).toHaveBeenCalledWith(
        'Received webhook',
        expect.objectContaining(mockWebhookData)
      );
    });

    it('should log errors', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      
      // Create an error that will be thrown during webhook processing
      const mockError = new Error('Invalid webhook data');
      mockError.name = 'ValidationError';
      
      // Mock the webhook handler to throw the error
      const mockWebhookData = { invalid: 'data' };
      const mockReq = { body: mockWebhookData };
      const mockRes = { status: jest.fn().mockReturnThis(), send: jest.fn() };
      
      // Mock the handleMention method to throw an error
      jest.spyOn(service as any, 'handleMention').mockImplementation(() => {
        throw mockError;
      });
      
      // Get the post handler and simulate the error
      const postHandler = (mockExpress().post as jest.Mock).mock.calls[0][1];
      await postHandler(mockReq, mockRes);

      expect(mockLogger.error).toHaveBeenCalledWith(
        'Error processing webhook',
        expect.objectContaining({
          error: mockError,
          body: mockWebhookData
        })
      );
    });

    it('should log rate limit warnings', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      // Mock Twitter API to throw rate limit error
      const mockError = new Error('Rate limit exceeded');
      (mockError as any).rateLimitError = true;
      
      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      await service.start();
      
      try {
        await service['replyToTweet']('123', 'test reply');
      } catch (error) {
        // Expected error
      }

      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Rate limited when attempting to respond to tweet',
        expect.objectContaining({
          tweetId: '123',
          message: 'test reply',
          error: expect.any(Error)
        })
      );
    });
  });
});

================
File: src/__tests__/TwitterServiceLive.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi, TweetV2, ReferencedTweetV2, TTweetv2Expansion } from 'twitter-api-v2';
import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// Skip these tests if not in CI or if credentials are not provided
const shouldRunLiveTests = process.env.CI === 'true' || process.env.RUN_LIVE_TESTS === 'true';

// Debug logging
console.log('Environment variables check:');
console.log('RUN_LIVE_TESTS:', process.env.RUN_LIVE_TESTS);
console.log('CI:', process.env.CI);
console.log('shouldRunLiveTests:', shouldRunLiveTests);
console.log('X_API_KEY exists:', !!process.env.X_API_KEY);
console.log('X_API_SECRET exists:', !!process.env.X_API_SECRET);
console.log('X_BEARER_TOKEN exists:', !!process.env.X_BEARER_TOKEN);
console.log('X_ACCESS_TOKEN exists:', !!process.env.X_ACCESS_TOKEN);
console.log('X_ACCESS_TOKEN_SECRET exists:', !!process.env.X_ACCESS_TOKEN_SECRET);

// Only run these tests if we have the required environment variables
const hasCredentials = 
  process.env.X_API_KEY &&
  process.env.X_API_SECRET &&
  process.env.X_ACCESS_TOKEN &&
  process.env.X_ACCESS_TOKEN_SECRET;

console.log('hasCredentials:', hasCredentials);

describe('TwitterService Live Tests', () => {
  let service: TwitterService;
  let twitterClient: TwitterApi;

  beforeAll(async () => {
    if (shouldRunLiveTests && hasCredentials) {
      const config: TwitterServiceConfig = {
        apiKey: process.env.X_API_KEY || '',
        apiSecret: process.env.X_API_SECRET || '',
        accessToken: process.env.X_ACCESS_TOKEN,
        accessTokenSecret: process.env.X_ACCESS_TOKEN_SECRET,
        pollIntervalMs: 1000 // Use shorter polling interval for tests
      };

      twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
        accessToken: config.accessToken!,
        accessSecret: config.accessTokenSecret!
      });

      service = new TwitterService(config);
    }
  });

  afterEach(async () => {
    if (service) {
      await service.stop();
    }
  });

  // Helper function to create a tweet
  const postTweet = async (content: string): Promise<string> => {
    try {
      const client = twitterClient.readWrite;
      const response = await client.v2.tweet(content);
      if (!response.data?.id) {
        throw new Error('Failed to create tweet: No tweet ID returned');
      }
      console.log('Tweet created:', JSON.stringify(response.data, null, 2));
      return response.data.id;
    } catch (error: any) {
      console.error('Failed to create tweet:', {
        message: error?.message,
        code: error?.code,
        data: error?.data
      });
      throw error;
    }
  };

  // Helper function to delete a tweet
  const deleteTweet = async (tweetId: string): Promise<void> => {
    try {
      const client = twitterClient.readWrite;
      await client.v2.deleteTweet(tweetId);
    } catch (error) {
      console.warn(`Failed to delete tweet ${tweetId}:`, error);
    }
  };

  describe('Live API Tests', () => {
    (shouldRunLiveTests && hasCredentials ? describe : describe.skip)('API Integration', () => {
      it('should get authenticated user info', async () => {
        try {
          const tweetId = await postTweet(`Test tweet to get user info ${Date.now()}`);
          expect(tweetId).toBeDefined();
          await deleteTweet(tweetId);
        } catch (error: any) {
          console.error('API Error:', {
            message: error?.message,
            code: error?.code,
            data: error?.data
          });
          throw error;
        }
      });

      describe('Tweet Interactions', () => {
        it('should correctly process a new mention and respond to it', async () => {
          await service.start();
          console.log('Service started');
          
          let testTweetId: string | undefined;
          try {
            // Create a mention tweet
            const client = twitterClient.readWrite;
            const me = await client.v2.me();
            testTweetId = await postTweet(`Test mention @${me.data.username} ${Date.now()}`);
            console.log('Created test tweet with ID:', testTweetId);
            expect(testTweetId).toBeDefined();
            
            // Wait for the mention to be processed
            return new Promise<void>((resolve) => {
              console.log('Setting up newMention event listener');
              service.on('newMention', async (mention: MentionEvent) => {
                console.log('Received mention event:', mention);
                expect(mention).toBeDefined();
                expect(mention.tweetId).toBe(testTweetId);
                
                // Test replying to the tweet
                console.log('Attempting to reply to tweet');
                await service['replyToTweet'](mention.tweetId, 'Test reply');
                
                // Verify the reply
                console.log('Verifying reply');
                const timeline = await client.v2.userTimeline(mention.userId, {
                  expansions: ['referenced_tweets.id'] as TTweetv2Expansion[],
                });
                
                const reply = timeline.tweets.find((t: TweetV2) =>
                  t.referenced_tweets?.some((ref: ReferencedTweetV2) =>
                    ref.type === 'replied_to' && ref.id === testTweetId
                  )
                );
                
                console.log('Found reply:', reply);
                expect(reply).toBeDefined();
                expect(reply?.text).toBe('Test reply');
                
                resolve();
              });
            });
          } catch (error: any) {
            console.error('API Error:', {
              message: error?.message,
              code: error?.code,
              data: error?.data
            });
            throw error;
          } finally {
            if (testTweetId) {
              await deleteTweet(testTweetId);
            }
          }
        }, 60000);

        it('should handle rate limits gracefully', async () => {
          await service.start();
          await new Promise(resolve => setTimeout(resolve, 1000));
          const tweets: string[] = [];
          
          try {
            // Create multiple tweets rapidly to trigger rate limit
            for (let i = 0; i < 5; i++) {
              try {
                const tweet = await twitterClient.v2.tweet(`Rate limit test tweet ${i}`);
                console.log('Tweet response:', JSON.stringify(tweet, null, 2));
                if (tweet?.data?.id) {
                  tweets.push(tweet.data.id);
                }
              } catch (error: any) {
                console.error('Tweet creation error:', {
                  message: error?.message,
                  code: error?.code,
                  data: error?.data
                });
                throw error;
              }
              // Add a small delay between tweets to avoid immediate rate limiting
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            let rateLimitWarningReceived = false;
            service.on('rateLimitWarning', () => {
              rateLimitWarningReceived = true;
            });
            
            // Try to reply to all tweets rapidly
            await Promise.all(
              tweets.map(tweetId => 
                service['replyToTweet'](tweetId, 'Test reply')
              )
            );
            
            expect(rateLimitWarningReceived).toBe(true);
          } finally {
            // Cleanup
            for (const tweetId of tweets) {
              if (tweetId) {
                try {
                  await twitterClient.v2.deleteTweet(tweetId);
                } catch (error) {
                  console.warn(`Failed to delete tweet ${tweetId}:`, error);
                }
                // Add a small delay between deletions
                await new Promise(resolve => setTimeout(resolve, 500));
              }
            }
          }
        }, 60000);
      });
    });
  });
});

================
File: src/checkAuth.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

async function checkAuth() {
  const client = new TwitterApi({
    appKey: process.env.X_API_KEY!,
    appSecret: process.env.X_API_SECRET!,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
  });

  try {
    const me = await client.v2.me();
    console.log('Authenticated as:', me.data);
  } catch (error) {
    console.error('Authentication error:', error);
  }
}

checkAuth();

================
File: src/index.ts
================
import { TwitterServiceConfig, MentionEvent, Message, ThreadContext, RateLimitEvent } from "./types";
import winston from "winston";
import { EventEmitter } from "events";
import { TwitterApi } from "twitter-api-v2";

/**
 * Service for handling Twitter interactions using polling
 */
export class TwitterService {
  private config: TwitterServiceConfig;
  private logger: winston.Logger;
  private emitter: EventEmitter;
  private twitterClient: TwitterApi;
  private threads: Map<string, ThreadContext>;
  private pollInterval?: NodeJS.Timeout;
  private lastMentionId?: string;

  public on: (event: string | symbol, listener: (...args: any[]) => void) => EventEmitter;
  public emit: (event: string | symbol, ...args: any[]) => boolean;

  /**
   * Creates a new instance of TwitterService
   * @param config - Configuration options for the service
   */
  constructor(config: TwitterServiceConfig) {
    this.config = {
      ...config,
      threadHistoryLimit: config.threadHistoryLimit ?? 50,
      pollIntervalMs: config.pollIntervalMs ?? 60000, // Default to 1 minute
    };
    this.threads = new Map();
    this.emitter = new EventEmitter();

    // Bind event emitter methods
    this.on = this.emitter.on.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);

    // Initialize logger with timestamp
    this.logger = winston.createLogger({
      level: "info",
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(({ level, message, timestamp, ...meta }) => {
          return `${timestamp} [${level}]: ${message} ${
            Object.keys(meta).length ? JSON.stringify(meta) : ""
          }`;
        })
      ),
      transports: [new winston.transports.Console()],
    });

    // Initialize Twitter client with the most specific credentials available
    if (config.accessToken && config.accessTokenSecret) {
      // Use user-specific credentials if available
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
        accessToken: config.accessToken,
        accessSecret: config.accessTokenSecret,
      });
    } else if (config.bearerToken) {
      // Fall back to bearer token if available
      this.twitterClient = new TwitterApi(config.bearerToken);
    } else {
      // Fall back to app-only credentials
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
      });
    }
  }

  /**
   * Starts the Twitter service and polling mechanism
   */
  public async start() {
    try {
      // Get authenticated user info for mention filtering
      const me = await this.twitterClient.v2.verifyCredentials();
      this.logger.info(`Starting service for user @${me.data.username}`);

      // Start polling for mentions
      await this.pollForMentions();
      this.pollInterval = setInterval(
        () => this.pollForMentions(),
        this.config.pollIntervalMs
      );

      this.logger.info("Twitter service started");
    } catch (error) {
      this.logger.error("Failed to start Twitter service", { error });
      throw error;
    }
  }

  /**
   * Stops the Twitter service and cleans up resources
   */
  public async stop() {
    try {
      if (this.pollInterval) {
        clearInterval(this.pollInterval);
        this.pollInterval = undefined;
      }

      // Clear all event listeners
      this.emitter.removeAllListeners();
      
      // Clear thread history
      this.threads.clear();

      this.logger.info("Twitter service stopped");
    } catch (error) {
      this.logger.error("Failed to stop Twitter service", { error });
      throw error;
    }
  }

  /**
   * Polls Twitter API for new mentions
   */
  private async pollForMentions() {
    try {
      const me = await this.twitterClient.v2.verifyCredentials();
      
      const searchResponse = await this.twitterClient.v2.searchAll({
        query: `@${me.data.username}`,
        "tweet.fields": ["conversation_id", "author_id", "created_at"],
        since_id: this.lastMentionId,
        max_results: 100
      });
      
      if (!searchResponse.data) return;
      
      const tweets = Array.isArray(searchResponse.data) ? searchResponse.data : [searchResponse.data];
      if (tweets.length > 0) {
        this.lastMentionId = tweets[0].id; // Update last mention ID
        
        // Process mentions in chronological order (oldest first)
        for (const mention of [...tweets].reverse()) {
          await this.handleMention({
            tweet: {
              text: mention.text,
              id: mention.id,
              conversation_id: mention.conversation_id,
              author_id: mention.author_id,
              created_at: mention.created_at
            }
          });
        }
      }
    } catch (error: any) {
      if (error?.rateLimitError) {
        this.logger.warn("Rate limited when polling for mentions", { error });
        this.emit("rateLimitWarning", { error });
      } else {
        this.logger.error("Error polling for mentions", { error });
        this.emit("pollError", { error });
      }
    }
  }

  /**
   * Processes mention events
   */
  private async handleMention(mention: any) {
    this.logger.info("Processing mention", mention);

    const tweet = mention.tweet;
    if (!tweet) {
      this.logger.warn("No tweet data in mention", { mention });
      return;
    }

    this.logger.info("Valid mention", {
      text: tweet.text,
      id: tweet.id,
    });

    const mentionEvent: MentionEvent = {
      message: tweet.text,
      threadId: tweet.conversation_id,
      userId: tweet.author_id,
      tweetId: tweet.id,
    };

    // Add message to thread context
    this.addMessageToThread(mentionEvent.threadId, {
      senderId: mentionEvent.userId,
      timestamp: Date.now(),
      content: mentionEvent.message,
    });

    this.emit("newMention", mentionEvent);
  }

  /**
   * Replies to a tweet with the given message
   */
  private async replyToTweet(tweetId: string, message: string) {
    try {
      const response = await this.twitterClient.v2.reply(message, tweetId);
      this.logger.info("Successfully responded to tweet", {
        tweetId,
        message,
        response,
      });
      return response;
    } catch (error: any) {
      if (error?.rateLimitError) {
        const rateLimitEvent: RateLimitEvent = {
          tweetId,
          message,
          error,
        };
        this.logger.warn("Rate limited when attempting to respond to tweet", rateLimitEvent);
        this.emit("rateLimitWarning", rateLimitEvent);
      } else {
        this.logger.error("Failed to respond to tweet", {
          tweetId,
          message,
          error,
        });
        this.emit("tweetError", { tweetId, message, error });
      }
      throw error;
    }
  }

  /**
   * Gets the context for a thread, creating it if it doesn't exist
   */
  private getThreadContext(threadId: string): ThreadContext {
    if (this.threads.has(threadId)) {
      return this.threads.get(threadId)!;
    } else {
      const newThread = { threadId: threadId, history: [] };
      this.threads.set(threadId, newThread);
      return newThread;
    }
  }

  /**
   * Adds a message to a thread's history, respecting the history limit if set
   */
  private addMessageToThread(threadId: string, message: Message) {
    const threadContext = this.getThreadContext(threadId);
    threadContext.history.push(message);

    // Apply history limit if configured
    if (this.config.threadHistoryLimit && threadContext.history.length > this.config.threadHistoryLimit) {
      threadContext.history = threadContext.history.slice(-this.config.threadHistoryLimit);
    }
  }
}

================
File: src/registerWebhook.ts
================
import dotenv from 'dotenv';
import { TwitterApi } from 'twitter-api-v2';

dotenv.config();

async function registerWebhook() {
  const webhookUrl = 'https://e639-151-205-184-89.ngrok-free.app/webhook/twitter';
  
  try {
    // Initialize the Twitter client with the new credentials
    const client = new TwitterApi({
      appKey: process.env.X_API_KEY!,
      appSecret: process.env.X_API_SECRET!,
      accessToken: process.env.X_ACCESS_TOKEN,
      accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
    });

    // Verify credentials
    console.log('Verifying credentials...');
    const me = await client.v2.me();
    console.log('Authenticated as:', JSON.stringify(me.data, null, 2));

    // Get the bearer token
    console.log('\nGetting app context...');
    const appClient = await client.appLogin();
    console.log('App authentication successful');

    // List current webhooks
    console.log('\nListing current webhooks...');
    const currentWebhooks = await client.v2.get('webhook/subscriptions/list');
    console.log('Current webhooks:', JSON.stringify(currentWebhooks.data, null, 2));

    // Register new webhook
    console.log('\nRegistering webhook...');
    const registerResponse = await client.v2.post('webhook/subscriptions/create', {
      url: webhookUrl,
      enabled: true
    });
    console.log('Registration response:', JSON.stringify(registerResponse.data, null, 2));

    // Subscribe to events
    console.log('\nSubscribing to webhook events...');
    const subscribeResponse = await client.v2.post('webhook/subscriptions/subscribe', {
      webhook_id: registerResponse.data.id,
      subscription_type: 'all'
    });
    console.log('Subscription response:', JSON.stringify(subscribeResponse.data, null, 2));

    console.log('\nWebhook setup completed!');
    console.log('Webhook URL:', webhookUrl);

  } catch (error: any) {
    console.error('Error:', {
      message: error?.message,
      status: error?.code,
      data: error?.data
    });
    
    if (error?.code === 403) {
      console.error('\nIt seems your API keys might not have the required permissions.');
      console.log('\nPlease ensure:');
      console.log('1. Your Twitter App has "Read, Write, and Direct Messages" permissions');
      console.log('2. The callback URLs in the Twitter Developer Portal include:');
      console.log(`   - ${webhookUrl}`);
      console.log('3. You have regenerated your access tokens after updating permissions');
    }
  }
}

registerWebhook();

================
File: src/testApi.ts
================
import crypto from 'crypto';
import OAuth from 'oauth-1.0a';
import dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

const oauth = new OAuth({
  consumer: {
    key: process.env.X_API_KEY!,
    secret: process.env.X_API_SECRET!
  },
  signature_method: 'HMAC-SHA1',
  hash_function(base_string, key) {
    return crypto
      .createHmac('sha1', key)
      .update(base_string)
      .digest('base64');
  },
});

async function makeAuthenticatedRequest(endpoint: string, method: string, data?: any) {
  const request_data = {
    url: `https://api.twitter.com/2/${endpoint}`,
    method
  };

  const token = {
    key: process.env.X_ACCESS_TOKEN!,
    secret: process.env.X_ACCESS_TOKEN_SECRET!
  };

  const authorization = oauth.authorize(request_data, token);
  const headers = oauth.toHeader(authorization);

  try {
    const response = await axios({
      url: request_data.url,
      method: request_data.method,
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      ...(data ? { data } : {})
    });

    return response.data;
  } catch (error: any) {
    console.error(`Error with ${endpoint}:`, {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data
    });
    throw error;
  }
}

async function testApi() {
  try {
    // Test 1: Get authenticated user info
    console.log('\n1. Testing user authentication');
    const meData = await makeAuthenticatedRequest('users/me', 'GET');
    console.log('✅ User info:', meData);

    // Test 2: Create a tweet
    console.log('\n2. Testing tweet creation');
    const tweetData = await makeAuthenticatedRequest('tweets', 'POST', {
      text: 'Test tweet ' + Date.now()
    });
    console.log('✅ Tweet created:', tweetData);
    const tweetId = tweetData.data.id;

    // Test 3: Reply to the tweet
    console.log('\n3. Testing reply to tweet');
    const replyData = await makeAuthenticatedRequest('tweets', 'POST', {
      text: 'Test reply ' + Date.now(),
      reply: {
        in_reply_to_tweet_id: tweetId
      }
    });
    console.log('✅ Reply created:', replyData);

    // Test 4: Delete the tweets
    console.log('\n4. Testing tweet deletion');
    const deleteData = await makeAuthenticatedRequest(`tweets/${tweetId}`, 'DELETE');
    console.log('✅ Tweet deleted:', deleteData);

  } catch (error) {
    console.error('Test failed:', error);
  }
}

console.log('Starting Twitter API tests...');
testApi().then(() => {
  console.log('\nAPI testing completed');
});

================
File: src/testEndpoints.ts
================
import crypto from 'crypto';
import OAuth from 'oauth-1.0a';
import dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

const oauth = new OAuth({
  consumer: {
    key: process.env.X_API_KEY!,
    secret: process.env.X_API_SECRET!
  },
  signature_method: 'HMAC-SHA1',
  hash_function(base_string, key) {
    return crypto
      .createHmac('sha1', key)
      .update(base_string)
      .digest('base64');
  },
});

async function makeAuthenticatedRequest(endpoint: string, method: string, data?: any) {
  const request_data = {
    url: `https://api.twitter.com/2/${endpoint}`,
    method
  };

  const token = {
    key: process.env.X_ACCESS_TOKEN!,
    secret: process.env.X_ACCESS_TOKEN_SECRET!
  };

  const authorization = oauth.authorize(request_data, token);
  const headers = oauth.toHeader(authorization);

  try {
    const response = await axios({
      url: request_data.url,
      method: request_data.method,
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      ...(data ? { data } : {})
    });

    return response.data;
  } catch (error: any) {
    console.error(`Error with ${endpoint}:`, {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data
    });
    throw error;
  }
}

async function testEndpoints() {
  console.log('\n1. Testing user authentication (me endpoint)');
  try {
    const meData = await makeAuthenticatedRequest('users/me', 'GET');
    console.log('✅ Successfully got user info:', meData);
  } catch (error) {
    console.log('❌ Failed to get user info');
  }

  console.log('\n2. Testing tweet creation');
  let tweetId;
  try {
    const tweetData = await makeAuthenticatedRequest('tweets', 'POST', {
      text: 'Test tweet for endpoint verification ' + Date.now()
    });
    tweetId = tweetData.data.id;
    console.log('✅ Successfully created tweet:', tweetData);
  } catch (error) {
    console.log('❌ Failed to create tweet');
    return; // Stop if we can't create a tweet
  }

  console.log('\n3. Testing reply to tweet');
  try {
    const replyData = await makeAuthenticatedRequest('tweets', 'POST', {
      text: 'Test reply ' + Date.now(),
      reply: {
        in_reply_to_tweet_id: tweetId
      }
    });
    console.log('✅ Successfully replied to tweet:', replyData);
  } catch (error) {
    console.log('❌ Failed to reply to tweet');
  }

  console.log('\n4. Testing user timeline');
  try {
    const meData = await makeAuthenticatedRequest('users/me', 'GET');
    const userId = meData.data.id;
    const timelineData = await makeAuthenticatedRequest(
      `users/${userId}/tweets?expansions=referenced_tweets.id`,
      'GET'
    );
    console.log('✅ Successfully got user timeline:', timelineData);
  } catch (error) {
    console.log('❌ Failed to get user timeline');
  }

  if (tweetId) {
    console.log('\n5. Testing tweet deletion');
    try {
      const deleteData = await makeAuthenticatedRequest(`tweets/${tweetId}`, 'DELETE');
      console.log('✅ Successfully deleted tweet:', deleteData);
    } catch (error) {
      console.log('❌ Failed to delete tweet');
    }
  }
}

console.log('Starting Twitter API endpoint tests...');
testEndpoints().then(() => {
  console.log('\nEndpoint testing completed');
});

================
File: src/testTweet.ts
================
import crypto from 'crypto';
import OAuth from 'oauth-1.0a';
import dotenv from 'dotenv';
import axios from 'axios';

dotenv.config();

const oauth = new OAuth({
  consumer: {
    key: process.env.X_API_KEY!,
    secret: process.env.X_API_SECRET!
  },
  signature_method: 'HMAC-SHA1',
  hash_function(base_string, key) {
    return crypto
      .createHmac('sha1', key)
      .update(base_string)
      .digest('base64');
  },
});

async function testCreateTweet() {
  const request_data = {
    url: 'https://api.twitter.com/2/tweets',
    method: 'POST'
  };

  const token = {
    key: process.env.X_ACCESS_TOKEN!,
    secret: process.env.X_ACCESS_TOKEN_SECRET!
  };

  const authorization = oauth.authorize(request_data, token);
  const headers = oauth.toHeader(authorization);

  try {
    const response = await axios({
      url: request_data.url,
      method: request_data.method,
      headers: {
        ...headers,
        'Content-Type': 'application/json'
      },
      data: {
        text: 'Test tweet from API debugging ' + Date.now()
      }
    });

    console.log('Tweet created successfully:', response.data);
  } catch (error: any) {
    console.error('Error creating tweet:', {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      headers: error.response?.headers
    });
  }
}

testCreateTweet();

================
File: src/types.ts
================
import { z } from 'zod';

/**
 * Configuration options for the Twitter service
 */
export interface TwitterServiceConfig {
  /** Twitter API Key */
  apiKey: string;
  /** Twitter API Secret */
  apiSecret: string;
  /** Optional bearer token for authentication */
  bearerToken?: string;
  /** Optional access token for user-specific actions */
  accessToken?: string;
  /** Optional access token secret for user-specific actions */
  accessTokenSecret?: string;
  /** Maximum number of messages to keep in thread history */
  threadHistoryLimit?: number;
  /** Interval in milliseconds between polling for mentions */
  pollIntervalMs?: number;
}

/**
 * Event emitted when a new mention is received
 */
export interface MentionEvent {
  /** ID of the conversation thread */
  threadId: string;
  /** ID of the user who created the mention */
  userId: string;
  /** Content of the mention */
  message: string;
  /** ID of the tweet */
  tweetId: string;
}

/**
 * Represents a message in a thread
 */
export interface Message {
  /** ID of the user who sent the message */
  senderId: string;
  /** Unix timestamp of when the message was sent */
  timestamp: number;
  /** Content of the message */
  content: string;
}

/**
 * Context for a conversation thread
 */
export interface ThreadContext {
  /** ID of the thread */
  threadId: string;
  /** History of messages in the thread */
  history: Message[];
}

/**
 * Rate limit error event
 */
export interface RateLimitEvent {
  /** ID of the tweet that triggered the rate limit */
  tweetId: string;
  /** Message that was attempted to be sent */
  message: string;
  /** Error details from Twitter API */
  error: any;
}

/**
 * Twitter entity mention
 */
const twitterMentionSchema = z.object({
  username: z.string(),
  id: z.string(),
});

/**
 * Twitter entities object
 */
const twitterEntitiesSchema = z.object({
  mentions: z.array(twitterMentionSchema).optional(),
});

/**
 * Referenced tweet object
 */
const referencedTweetSchema = z.object({
  type: z.string(),
  id: z.string(),
});

/**
 * Tweet object schema
 */
const tweetSchema = z.object({
  text: z.string(),
  id: z.string(),
  conversation_id: z.string(),
  author_id: z.string(),
  created_at: z.string().optional(),
  in_reply_to_user_id: z.string().optional(),
  referenced_tweets: z.array(referencedTweetSchema).optional(),
  entities: twitterEntitiesSchema.optional(),
});

/**
 * Direct message data schema
 */
const directMessageDataSchema = z.object({
  text: z.string(),
  entities: z.record(z.any()).optional(),
});

/**
 * Direct message create schema
 */
const directMessageCreateSchema = z.object({
  message_data: directMessageDataSchema,
  sender_id: z.string(),
  target: z.object({
    recipient_id: z.string(),
  }).optional(),
});

/**
 * Direct message event schema
 */
const directMessageEventSchema = z.object({
  type: z.string(),
  id: z.string(),
  message_create: directMessageCreateSchema,
});

/**
 * Zod schema for validating Twitter webhook payloads
 */
export const twitterWebhookSchema = z.object({
  tweet: tweetSchema.optional(),
  direct_message_events: z.array(directMessageEventSchema).optional(),
});

================
File: .env.example
================
# X (Twitter) API Credentials
# Get these from the X Developer Portal (https://developer.twitter.com/en/portal/dashboard)
X_API_KEY=
X_API_SECRET=
X_BEARER_TOKEN=
X_ACCESS_TOKEN=
X_ACCESS_TOKEN_SECRET=
X_CLIENT_ID=
X_CLIENT_SECRET=

# Test Control
# Set to true to enable live API tests locally
RUN_LIVE_TESTS=false

# Optional: Test Account Information
# The X account ID that will be used for testing
# TEST_ACCOUNT_ID=
# The X username that will be used for testing
# TEST_ACCOUNT_USERNAME=

================
File: .eslintrc.json
================
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }]
  }
}

================
File: .gitignore
================
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
build/

# Environment variables
.env
.env.local
.env.*.local

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Logs
logs/
*.log

# Test coverage
coverage/

================
File: .prettierrc
================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: ['/node_modules/', '/__tests__/'],
};

================
File: package.json
================
{
  "name": "@dao-bot/twitter-service",
  "version": "1.0.0",
  "description": "Twitter service for DAO Bot",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "prepublishOnly": "npm run build",
    "dev": "tsc -w",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepare": "npm run build",
    "test:live": "node -r dotenv/config ./node_modules/.bin/jest"
  },
  "keywords": [
    "twitter",
    "dao",
    "bot"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "express": "^4.21.2",
    "oauth-1.0a": "^2.2.6",
    "twitter-api-v2": "^1.19.0",
    "winston": "^3.17.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/axios": "^0.9.36",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.11",
    "@types/node": "^22.10.5",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "axios": "^1.7.9",
    "dotenv": "^16.4.7",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "jest": "^29.7.0",
    "ngrok": "^5.0.0-beta.2",
    "prettier": "^3.2.2",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.2"
  }
}

================
File: README.md
================
# @dao-bot/twitter-service

A Twitter service for DAO Bot that handles Twitter API interactions, webhook processing, and thread context management.

## Installation

```bash
npm install @dao-bot/twitter-service
```

## Setup

1. Create a Twitter Developer Account and set up a Project
   - Go to [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard)
   - Create a new Project and App
   - Get your API Key and API Secret
   - Set up OAuth 2.0 credentials
   - (Optional) Generate a Bearer Token

2. Configure your environment
   - Set up a webhook endpoint that's publicly accessible
   - Ensure your server can receive POST requests at your webhook URL

## Usage

```typescript
import { TwitterService } from '@dao-bot/twitter-service';

// Initialize the service
const twitterService = new TwitterService({
  apiKey: 'your_api_key',
  apiSecret: 'your_api_secret',
  webhookPort: 3000,
  // Optional: bearerToken: 'your_bearer_token'
});

// Handle new mentions
twitterService.on('newMention', async (mentionEvent) => {
  console.log('New mention:', mentionEvent);
  // Handle the mention event
  // mentionEvent contains:
  // - threadId: string
  // - userId: string
  // - message: string
  // - tweetId: string
});

// Start the service
await twitterService.start();
```

## Features

- Webhook endpoint for receiving Twitter events
- Event-based architecture for handling mentions
- Thread context management
- Rate limit handling
- Structured logging
- TypeScript support

## Types

### TwitterServiceConfig
```typescript
interface TwitterServiceConfig {
  apiKey: string;
  apiSecret: string;
  webhookPort: number;
  bearerToken?: string;
}
```

### MentionEvent
```typescript
interface MentionEvent {
  threadId: string;
  userId: string;
  message: string;
  tweetId: string;
}
```

### Message
```typescript
interface Message {
  senderId: string;
  timestamp: number;
  content: string;
}
```

### ThreadContext
```typescript
interface ThreadContext {
  threadId: string;
  history: Message[];
}
```

## Development

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Start in development mode
npm run dev

# Build and start
npm start
```

## License

ISC

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "sourceMap": true,
    "moduleResolution": "node",
    "declaration": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-08T01:08:33.670Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  __mocks__/
    express.ts
    twitter-api-v2.ts
    winston.ts
  __tests__/
    schema.test.ts
    TwitterService.test.ts
    TwitterServiceLive.test.ts
  index.ts
  types.ts
.env.example
.eslintrc.json
.gitignore
.prettierrc
jest.config.js
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/__mocks__/express.ts
================
import { Request, Response } from 'express';
import { EventEmitter } from 'events';

export interface MockResponse extends Partial<Response> {
  status: jest.Mock;
  send: jest.Mock;
  json: jest.Mock;
  end: jest.Mock;
  setHeader: jest.Mock;
  getHeader: jest.Mock;
}

export interface MockRequest extends Partial<Request> {
  body?: any;
  headers?: Record<string, string>;
  query?: Record<string, string>;
  params?: Record<string, string>;
}

export interface MockServer extends EventEmitter {
  on: jest.Mock;
  emit: jest.Mock;
  close: jest.Mock;
}

export interface MockApp {
  use: jest.Mock;
  post: jest.Mock;
  get: jest.Mock;
  listen: jest.Mock;
}

export interface MockExpress {
  (): MockApp;
  json: jest.Mock;
  urlencoded: jest.Mock;
  static: jest.Mock;
}

// Create mock response factory
const createMockResponse = (): MockResponse => {
  const res: MockResponse = {
    status: jest.fn().mockReturnThis(),
    send: jest.fn().mockReturnThis(),
    json: jest.fn().mockReturnThis(),
    end: jest.fn().mockReturnThis(),
    setHeader: jest.fn().mockReturnThis(),
    getHeader: jest.fn(),
  };
  return res;
};

// Create mock server factory with direct EventEmitter usage
const createMockServer = (): MockServer => {
  const server = new EventEmitter() as MockServer;
  server.on = jest.fn().mockImplementation((event: string, handler: (...args: any[]) => void) => {
    server.addListener(event, handler);
    return server;
  });
  server.emit = jest.fn().mockImplementation((event: string, ...args: any[]) => {
    return EventEmitter.prototype.emit.call(server, event, ...args);
  });
  server.close = jest.fn().mockImplementation((callback?: () => void) => {
    if (callback) callback();
    return server;
  });
  return server;
};

// Create mock app factory with enhanced functionality
const createMockApp = (server: MockServer): MockApp => ({
  use: jest.fn(),
  post: jest.fn(),
  get: jest.fn(),
  listen: jest.fn((port: number, cb?: () => void) => {
    if (cb) cb();
    return server;
  }),
});

// Create mock express factory with additional middleware support
const createMockExpress = (): MockExpress => {
  const mockServer = createMockServer();
  const mockApp = createMockApp(mockServer);
  
  const mockExpress = jest.fn(() => mockApp) as unknown as MockExpress;
  mockExpress.json = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.urlencoded = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.static = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  
  return mockExpress;
};

export default createMockExpress();

================
File: src/__mocks__/twitter-api-v2.ts
================
import { TwitterApi as RealTwitterApi } from 'twitter-api-v2';

export interface MockTwitterApiV2 {
  reply: jest.Mock;
  tweet: jest.Mock;
  userTimeline: jest.Mock;
  deleteTweet: jest.Mock;
  _prefix: string;
  readWrite: Record<string, unknown>;
  labs: Record<string, unknown>;
  readOnly: Record<string, unknown>;
}

export interface MockTwitterApi {
  v2: MockTwitterApiV2;
}

// Create mock Twitter API v2 instance
const createMockTwitterApiV2 = (): MockTwitterApiV2 => ({
  reply: jest.fn(),
  tweet: jest.fn(),
  userTimeline: jest.fn(),
  deleteTweet: jest.fn(),
  _prefix: '',
  readWrite: {},
  labs: {},
  readOnly: {},
});

// Create mock Twitter API factory
const createMockTwitterApi = () => {
  const mockTwitterApiV2 = createMockTwitterApiV2();
  const MockTwitterApi = jest.fn().mockImplementation(() => ({
    v2: mockTwitterApiV2,
    getErrors: jest.fn(),
    getProfileImageInSize: jest.fn(),
  }));

  return MockTwitterApi as unknown as jest.MockedClass<typeof RealTwitterApi>;
};

export const TwitterApi = createMockTwitterApi();

================
File: src/__mocks__/winston.ts
================
interface LogMethod {
  (message: string, ...meta: any[]): void;
  (info: object): void;
}

interface MockLogger {
  info: jest.Mock;
  error: jest.Mock;
  warn: jest.Mock;
  debug: jest.Mock;
  log: jest.Mock;
}

interface MockWinston {
  createLogger: jest.Mock;
  format: {
    combine: jest.Mock;
    timestamp: jest.Mock;
    printf: jest.Mock;
    colorize: jest.Mock;
  };
  transports: {
    Console: jest.Mock;
  };
}

// Create mock logger factory
const createMockLogger = (): MockLogger => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
  log: jest.fn(),
});

// Create mock winston instance
const mockWinston: MockWinston = {
  createLogger: jest.fn().mockReturnValue(createMockLogger()),
  format: {
    combine: jest.fn(),
    timestamp: jest.fn(),
    printf: jest.fn(),
    colorize: jest.fn(),
  },
  transports: {
    Console: jest.fn(),
  },
};

export = mockWinston;

================
File: src/__tests__/schema.test.ts
================
import { twitterWebhookSchema } from '../types';

describe('Twitter Webhook Schema', () => {
  describe('tweet events', () => {
    it('should validate a valid tweet webhook payload', () => {
      const validPayload = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          created_at: '2024-01-07T12:00:00Z',
          in_reply_to_user_id: 'user456',
        },
      };

      const result = twitterWebhookSchema.safeParse(validPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(validPayload);
        expect(result.data.tweet?.text).toBe('Hello, world!');
        expect(result.data.tweet?.author_id).toBe('user123');
      }
    });

    it('should validate a tweet with optional fields', () => {
      const tweetWithOptionals = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          referenced_tweets: [
            { type: 'replied_to', id: '987654321' },
          ],
          entities: {
            mentions: [{ username: 'test', id: 'user456' }],
          },
        },
      };

      const result = twitterWebhookSchema.safeParse(tweetWithOptionals);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.referenced_tweets).toBeDefined();
        expect(result.data.tweet?.entities?.mentions).toBeDefined();
      }
    });

    it('should validate a tweet with multiple referenced tweets', () => {
      const tweetWithMultipleRefs = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
          referenced_tweets: [
            { type: 'replied_to', id: '987654321' },
            { type: 'quoted', id: '456789123' },
          ],
        },
      };

      const result = twitterWebhookSchema.safeParse(tweetWithMultipleRefs);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.referenced_tweets).toHaveLength(2);
      }
    });
  });

  describe('direct message events', () => {
    it('should validate a valid direct message event payload', () => {
      const validDirectMessagePayload = {
        direct_message_events: [{
          type: 'message_create',
          id: '123456789',
          message_create: {
            message_data: {
              text: 'Hello via DM',
              entities: {},
            },
            sender_id: 'sender123',
            target: {
              recipient_id: 'recipient456',
            },
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(validDirectMessagePayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(validDirectMessagePayload);
      }
    });

    it('should validate multiple direct message events', () => {
      const multipleDirectMessages = {
        direct_message_events: [
          {
            type: 'message_create',
            id: '123456789',
            message_create: {
              message_data: {
                text: 'First message',
                entities: {},
              },
              sender_id: 'sender123',
            },
          },
          {
            type: 'message_create',
            id: '987654321',
            message_create: {
              message_data: {
                text: 'Second message',
                entities: {},
              },
              sender_id: 'sender456',
            },
          },
        ],
      };

      const result = twitterWebhookSchema.safeParse(multipleDirectMessages);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.direct_message_events).toHaveLength(2);
      }
    });
  });

  describe('combined events', () => {
    it('should validate payload with both tweet and direct message events', () => {
      const combinedPayload = {
        tweet: {
          text: 'Hello, world!',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
        },
        direct_message_events: [{
          type: 'message_create',
          id: '987654321',
          message_create: {
            message_data: {
              text: 'Hello via DM',
              entities: {},
            },
            sender_id: 'sender123',
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(combinedPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet).toBeDefined();
        expect(result.data.direct_message_events).toBeDefined();
      }
    });
  });

  describe('empty and missing fields', () => {
    it('should validate payload without any event object', () => {
      const emptyPayload = {};
      const result = twitterWebhookSchema.safeParse(emptyPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).toEqual(emptyPayload);
      }
    });

    it('should validate payload with empty tweet object', () => {
      const emptyTweetPayload = {
        tweet: {
          text: '',
          id: '123456789',
          conversation_id: 'conv123',
          author_id: 'user123',
        },
      };

      const result = twitterWebhookSchema.safeParse(emptyTweetPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.tweet?.text).toBe('');
      }
    });

    it('should validate payload with empty direct message events array', () => {
      const emptyDMPayload = {
        direct_message_events: [],
      };

      const result = twitterWebhookSchema.safeParse(emptyDMPayload);
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.direct_message_events).toHaveLength(0);
      }
    });
  });

  describe('validation failures', () => {
    it('should fail validation for invalid tweet object structure', () => {
      const invalidPayload = {
        tweet: {
          // Missing required fields
          text: 'Hello, world!',
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidPayload);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues).toHaveLength(3); // Should have 3 missing field errors
        expect(result.error.issues[0].code).toBe('invalid_type');
      }
    });

    it('should fail validation for invalid field types', () => {
      const invalidTypes = {
        tweet: {
          text: 123, // Should be string
          id: 456, // Should be string
          conversation_id: true, // Should be string
          author_id: {}, // Should be string
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidTypes);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues).toHaveLength(4); // Should have 4 type errors
        expect(result.error.issues[0].code).toBe('invalid_type');
      }
    });

    it('should fail validation for invalid direct message structure', () => {
      const invalidDM = {
        direct_message_events: [{
          type: 'message_create',
          // Missing required fields
          message_create: {
            message_data: {
              // Missing text
            },
          },
        }],
      };

      const result = twitterWebhookSchema.safeParse(invalidDM);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues.length).toBeGreaterThan(0);
      }
    });

    it('should fail validation for invalid entities in tweet', () => {
      const invalidEntities = {
        tweet: {
          text: 'Hello',
          id: '123',
          conversation_id: 'conv123',
          author_id: 'user123',
          entities: {
            mentions: [
              { username: 123, id: true }, // Invalid types
            ],
          },
        },
      };

      const result = twitterWebhookSchema.safeParse(invalidEntities);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues.length).toBeGreaterThan(0);
      }
    });
  });
});

================
File: src/__tests__/TwitterService.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi } from 'twitter-api-v2';
import express from 'express';
import { MockApp, MockServer, MockRequest, MockResponse } from '../__mocks__/express';
import { MockTwitterApiV2 } from '../__mocks__/twitter-api-v2';
import mockExpress from '../__mocks__/express';

jest.mock('express');
jest.mock('twitter-api-v2');
jest.mock('winston');

const MockedTwitterApi = jest.mocked(TwitterApi);
const MockedExpress = jest.mocked(express);

describe('TwitterService', () => {
  let service: TwitterService;
  let mockApp: MockApp;
  let mockServer: MockServer;
  let mockTwitterApiV2: MockTwitterApiV2;
  
  const mockConfig: TwitterServiceConfig = {
    apiKey: 'test-key',
    apiSecret: 'test-secret',
    webhookPort: 3000,
    threadHistoryLimit: 50,
  };

  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    
    // Setup express mocks
    mockServer = {
      on: jest.fn(),
      emit: jest.fn(),
      close: jest.fn(),
      addListener: jest.fn(),
      once: jest.fn(),
      prependListener: jest.fn(),
      prependOnceListener: jest.fn(),
      removeListener: jest.fn(),
      removeAllListeners: jest.fn(),
      setMaxListeners: jest.fn(),
      getMaxListeners: jest.fn(),
      listeners: jest.fn(),
      rawListeners: jest.fn(),
      listenerCount: jest.fn(),
      eventNames: jest.fn(),
    } as unknown as MockServer;
    
    mockApp = {
      use: jest.fn(),
      post: jest.fn(),
      get: jest.fn(),
      listen: jest.fn().mockImplementation((port: number, cb?: () => void) => {
        if (cb) cb();
        return mockServer;
      }),
    };
    (MockedExpress as any).mockReturnValue(mockApp);
    
    // Setup Twitter API mock with full interface implementation
    mockTwitterApiV2 = {
      reply: jest.fn(),
      tweet: jest.fn(),
      userTimeline: jest.fn(),
      deleteTweet: jest.fn(),
      _prefix: '',
      readWrite: {},
      labs: {},
      readOnly: {},
    };
    
    const mockTwitterApi = {
      v2: mockTwitterApiV2,
      v1: {},
      readWrite: {},
      readOnly: {},
      currentUser: () => Promise.resolve({}),
      currentUserV2: () => Promise.resolve({}),
      login: jest.fn(),
      logout: jest.fn(),
      generateAuthLink: jest.fn(),
      generateOAuth2AuthLink: jest.fn(),
      refreshOAuth2AccessToken: jest.fn(),
      revokeOAuth2AccessToken: jest.fn(),
      clientId: '',
      clientSecret: '',
      basicToken: '',
      bearerToken: '',
      accessToken: '',
      accessSecret: '',
      scope: [],
      requestClient: {} as any,
      appLogin: jest.fn(),
      loginWithOAuth2: jest.fn(),
      search: jest.fn(),
    } as unknown as TwitterApi;
    
    MockedTwitterApi.mockImplementation(() => mockTwitterApi);
    
    service = new TwitterService(mockConfig);
  });

  describe('constructor', () => {
    it('should create instance with API key/secret', () => {
      expect(service).toBeInstanceOf(TwitterService);
      expect(MockedTwitterApi).toHaveBeenCalledWith({
        appKey: mockConfig.apiKey,
        appSecret: mockConfig.apiSecret,
      });
    });

    it('should create instance with bearer token', () => {
      const configWithBearer = {
        ...mockConfig,
        bearerToken: 'test-bearer-token',
      };
      const service = new TwitterService(configWithBearer);
      expect(service).toBeInstanceOf(TwitterService);
      expect(MockedTwitterApi).toHaveBeenCalledWith(configWithBearer.bearerToken);
    });

    it('should use default thread history limit if not provided', async () => {
      const service = new TwitterService({
        ...mockConfig,
        threadHistoryLimit: undefined,
      });
      const threadId = 'test-thread';
      const messages = Array.from({ length: 51 }, (_, i) => ({
        senderId: 'user1',
        timestamp: i,
        content: `message ${i}`,
      }));

      // Add messages one by one to ensure they are processed in order
      for (const msg of messages) {
        service['addMessageToThread'](threadId, msg);
      }

      // Get the context after all messages are added
      const context = service['getThreadContext'](threadId);
      
      // Should keep the most recent 50 messages
      expect(context.history).toHaveLength(50);
      // Should have messages 1-50 (not 0-49)
      expect(context.history[0].content).toBe('message 1');
      expect(context.history[49].content).toBe('message 50');
      // Verify messages are in order
      const contents = context.history.map(msg => msg.content);
      expect(contents).toEqual(messages.slice(1).map(msg => msg.content));
    });
  });

  describe('server initialization', () => {
    let mockExpressApp: MockApp;

    beforeEach(() => {
      // Reset express mock for each test
      jest.clearAllMocks();

      // Create a new mock server for each test
      mockServer = {
        on: jest.fn(),
        emit: jest.fn(),
        close: jest.fn(),
        addListener: jest.fn(),
        once: jest.fn(),
        prependListener: jest.fn(),
        prependOnceListener: jest.fn(),
        removeListener: jest.fn(),
        removeAllListeners: jest.fn(),
        setMaxListeners: jest.fn(),
        getMaxListeners: jest.fn(),
        listeners: jest.fn(),
        rawListeners: jest.fn(),
        listenerCount: jest.fn(),
        eventNames: jest.fn(),
      } as unknown as MockServer;

      // Create a new mock app for each test
      mockExpressApp = {
        use: jest.fn(),
        post: jest.fn(),
        get: jest.fn(),
        listen: jest.fn().mockImplementation((port: number, cb?: () => void) => {
          if (cb) cb();
          return mockServer;
        }),
      };

      // Setup the express mock
      (MockedExpress as any).mockReturnValue(mockExpressApp);
      (express.json as jest.Mock).mockReturnValue(jest.fn());

      // Create a new service instance
      service = new TwitterService(mockConfig);
    });

    it('should start server successfully', async () => {
      await service.start();
      expect(mockExpressApp.listen).toHaveBeenCalledWith(mockConfig.webhookPort, expect.any(Function));
    });

    it('should handle server startup error', async () => {
      const mockError = new Error('Server startup failed');
      mockServer.on.mockImplementation((event: string, handler: (error: Error) => void) => {
        if (event === 'error') {
          handler(mockError);
        }
      });

      const mockEmit = jest.spyOn(service, 'emit');
      await service.start();

      expect(mockServer.on).toHaveBeenCalledWith('error', expect.any(Function));
      expect(mockEmit).toHaveBeenCalledWith('serverError', mockError);
    });

    it('should handle express middleware error', async () => {
      const mockError = new Error('Middleware error');
      (express.json as jest.Mock).mockImplementation(() => {
        throw mockError;
      });

      await expect(service.start()).rejects.toThrow(mockError);
    });

    it('should handle port already in use error', async () => {
      const mockError = new Error('EADDRINUSE');
      mockServer.on.mockImplementation((event: string, handler: (error: Error) => void) => {
        if (event === 'error') {
          handler(mockError);
        }
      });

      const mockEmit = jest.spyOn(service, 'emit');
      await service.start();

      expect(mockServer.on).toHaveBeenCalledWith('error', expect.any(Function));
      expect(mockEmit).toHaveBeenCalledWith('serverError', mockError);
    });
  });

  describe('webhook handling', () => {
    it('should handle webhook processing error', async () => {
      const mockReq = {
        body: { invalid: 'data' },
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
    });

    it('should process valid webhook data', async () => {
      const validMention = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
        },
      };

      const mockReq = {
        body: validMention,
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };
      const mockEmit = jest.spyOn(service, 'emit');

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
      expect(mockEmit).toHaveBeenCalledWith('newMention', expect.any(Object));
    });

    it('should handle malformed JSON in webhook request', async () => {
      const mockReq = {
        body: undefined,
      };
      const mockRes = {
        status: jest.fn().mockReturnThis(),
        send: jest.fn(),
      };
      const mockEmit = jest.spyOn(service, 'emit');

      await service['webhook'](mockReq as any, mockRes as any);

      expect(mockRes.status).toHaveBeenCalledWith(200);
      expect(mockRes.send).toHaveBeenCalledWith('OK');
      expect(mockEmit).not.toHaveBeenCalledWith('newMention', expect.any(Object));
    });
  });

  describe('event handling', () => {
    it('should emit newMention event when valid mention is received', (done) => {
      const validMention = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
        },
      };

      service.on('newMention', (event: MentionEvent) => {
        expect(event).toEqual({
          message: validMention.tweet.text,
          threadId: validMention.tweet.conversation_id,
          userId: validMention.tweet.author_id,
          tweetId: validMention.tweet.id,
        });
        done();
      });

      service['handleMention'](validMention);
    });

    it('should not emit newMention event for invalid mention', () => {
      const invalidMention = {
        not_a_tweet: {},
      };

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](invalidMention);

      expect(mockEmit).not.toHaveBeenCalledWith('newMention', expect.any(Object));
    });

    it('should handle mentions with referenced tweets', () => {
      const mentionWithRefs = {
        tweet: {
          text: 'test mention',
          id: 'tweet-id',
          conversation_id: 'thread-id',
          author_id: 'user-id',
          referenced_tweets: [
            { type: 'replied_to', id: 'original-tweet' },
          ],
        },
      };

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](mentionWithRefs);

      expect(mockEmit).toHaveBeenCalledWith('newMention', expect.any(Object));
    });
  });

  describe('thread context', () => {
    it('should maintain thread history', () => {
      const threadId = 'test-thread';
      const message = {
        senderId: 'user1',
        timestamp: Date.now(),
        content: 'test message',
      };

      service['addMessageToThread'](threadId, message);
      const context = service['getThreadContext'](threadId);

      expect(context.threadId).toBe(threadId);
      expect(context.history).toHaveLength(1);
      expect(context.history[0]).toEqual(message);
    });

    it('should respect thread history limit', () => {
      const configWithLimit = {
        ...mockConfig,
        threadHistoryLimit: 2,
      };
      const service = new TwitterService(configWithLimit);
      const threadId = 'test-thread';

      const messages = [
        { senderId: 'user1', timestamp: 1, content: 'message 1' },
        { senderId: 'user1', timestamp: 2, content: 'message 2' },
        { senderId: 'user1', timestamp: 3, content: 'message 3' },
      ];

      messages.forEach(msg => service['addMessageToThread'](threadId, msg));
      const context = service['getThreadContext'](threadId);

      expect(context.history).toHaveLength(2);
      expect(context.history).toEqual([messages[1], messages[2]]);
    });

    it('should handle concurrent thread updates', async () => {
      const service = new TwitterService({
        ...mockConfig,
        threadHistoryLimit: 50,
      });
      const threadId = 'test-thread';
      const messages = Array.from({ length: 100 }, (_, i) => ({
        senderId: 'user1',
        timestamp: i,
        content: `message ${i}`,
      }));

      // Simulate concurrent updates
      await Promise.all(messages.map(msg => 
        Promise.resolve().then(() => service['addMessageToThread'](threadId, msg))
      ));

      const context = service['getThreadContext'](threadId);
      
      // Should respect the default limit of 50
      expect(context.history).toHaveLength(50);
      
      // Verify messages are in chronological order
      const timestamps = context.history.map(msg => msg.timestamp);
      const sortedTimestamps = [...timestamps].sort((a, b) => a - b);
      expect(timestamps).toEqual(sortedTimestamps);
      
      // Verify we have the last 50 messages
      expect(timestamps[0]).toBe(50); // Should start at message 50
      expect(timestamps[49]).toBe(99); // Should end at message 99
    });

    it('should handle multiple threads independently', () => {
      const thread1 = 'thread-1';
      const thread2 = 'thread-2';

      const message1 = { senderId: 'user1', timestamp: 1, content: 'thread 1 message' };
      const message2 = { senderId: 'user2', timestamp: 2, content: 'thread 2 message' };

      service['addMessageToThread'](thread1, message1);
      service['addMessageToThread'](thread2, message2);

      const context1 = service['getThreadContext'](thread1);
      const context2 = service['getThreadContext'](thread2);

      expect(context1.history[0]).toEqual(message1);
      expect(context2.history[0]).toEqual(message2);
    });
  });

  describe('error handling', () => {
    it('should emit rateLimitWarning when rate limited', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('Rate limit exceeded');
      (mockError as any).rateLimitError = true;

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      const serviceWithMock = new TwitterService(mockConfig);
      const mockEmit = jest.spyOn(serviceWithMock, 'emit');

      try {
        await serviceWithMock['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('rateLimitWarning', {
        tweetId,
        message,
        error: mockError,
      });
    });

    it('should handle successful tweet reply', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockResponse = { data: { id: 'reply-id' } };

      mockTwitterApiV2.reply.mockResolvedValueOnce(mockResponse);

      const response = await service['replyToTweet'](tweetId, message);
      expect(response).toEqual(mockResponse);
      expect(mockTwitterApiV2.reply).toHaveBeenCalledWith(message, tweetId);
    });

    it('should emit tweetError for non-rate-limit errors', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('API error');

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      const mockEmit = jest.spyOn(service, 'emit');

      try {
        await service['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('tweetError', {
        tweetId,
        message,
        error: mockError,
      });
    });

    it('should handle network errors during tweet reply', async () => {
      const tweetId = 'test-tweet';
      const message = 'test reply';
      const mockError = new Error('Network error');
      mockError.name = 'NetworkError';

      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);
      const mockEmit = jest.spyOn(service, 'emit');

      try {
        await service['replyToTweet'](tweetId, message);
      } catch (error) {
        expect(error).toBe(mockError);
      }

      expect(mockEmit).toHaveBeenCalledWith('tweetError', {
        tweetId,
        message,
        error: mockError,
      });
    });
  });

  describe('Logging', () => {
    let mockLogger: any;
    
    beforeEach(() => {
      // Get the mock logger instance
      mockLogger = require('winston').createLogger();
      
      // Mock the error method to capture meta objects
      mockLogger.error.mockImplementation((message: string, meta?: any) => {
        if (meta?.error instanceof Error) {
          return { message, meta };
        }
      });
      
      // Mock the warn method to capture meta objects
      mockLogger.warn.mockImplementation((message: string, meta?: any) => {
        if (meta?.error instanceof Error) {
          return { message, meta };
        }
      });
    });

    it('should log server start', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      expect(mockLogger.info).toHaveBeenCalledWith(
        expect.stringContaining('Server is running on port 3000')
      );
    });

    it('should log webhook events', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      
      // Simulate webhook event
      const mockWebhookData = {
        for_user_id: '123',
        tweet_create_events: [{
          id_str: '456',
          user: { id_str: '789' },
          text: 'test tweet'
        }]
      };

      // Get the post handler
      const postHandler = (mockExpress().post as jest.Mock).mock.calls[0][1];
      await postHandler({ body: mockWebhookData }, { status: jest.fn().mockReturnThis(), send: jest.fn() });

      expect(mockLogger.info).toHaveBeenCalledWith(
        'Received webhook',
        expect.objectContaining(mockWebhookData)
      );
    });

    it('should log errors', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      await service.start();
      
      // Create an error that will be thrown during webhook processing
      const mockError = new Error('Invalid webhook data');
      mockError.name = 'ValidationError';
      
      // Mock the webhook handler to throw the error
      const mockWebhookData = { invalid: 'data' };
      const mockReq = { body: mockWebhookData };
      const mockRes = { status: jest.fn().mockReturnThis(), send: jest.fn() };
      
      // Mock the handleMention method to throw an error
      jest.spyOn(service as any, 'handleMention').mockImplementation(() => {
        throw mockError;
      });
      
      // Get the post handler and simulate the error
      const postHandler = (mockExpress().post as jest.Mock).mock.calls[0][1];
      await postHandler(mockReq, mockRes);

      expect(mockLogger.error).toHaveBeenCalledWith(
        'Error processing webhook',
        expect.objectContaining({
          error: mockError,
          body: mockWebhookData
        })
      );
    });

    it('should log rate limit warnings', async () => {
      const service = new TwitterService({
        apiKey: 'test-key',
        apiSecret: 'test-secret',
        webhookPort: 3000,
      });

      // Mock Twitter API to throw rate limit error
      const mockError = new Error('Rate limit exceeded');
      (mockError as any).rateLimitError = true;
      
      mockTwitterApiV2.reply.mockRejectedValueOnce(mockError);

      await service.start();
      
      try {
        await service['replyToTweet']('123', 'test reply');
      } catch (error) {
        // Expected error
      }

      expect(mockLogger.warn).toHaveBeenCalledWith(
        'Rate limited when attempting to respond to tweet',
        expect.objectContaining({
          tweetId: '123',
          message: 'test reply',
          error: expect.any(Error)
        })
      );
    });
  });
});

================
File: src/__tests__/TwitterServiceLive.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi, TweetV2, ReferencedTweetV2, TTweetv2Expansion } from 'twitter-api-v2';
import express from 'express';
import axios from 'axios';
import { Server } from 'http';

// Skip these tests if not in CI or if credentials are not provided
const shouldRunLiveTests = process.env.CI || process.env.RUN_LIVE_TESTS;

// Only run these tests if we have the required environment variables
const hasCredentials = 
  process.env.X_API_KEY &&
  process.env.X_API_SECRET &&
  (process.env.X_BEARER_TOKEN || (process.env.X_ACCESS_TOKEN && process.env.X_ACCESS_TOKEN_SECRET));

describe('TwitterService Live Tests', () => {
  let service: TwitterService;
  let twitterClient: TwitterApi;

  const config: TwitterServiceConfig = {
    apiKey: process.env.X_API_KEY || '',
    apiSecret: process.env.X_API_SECRET || '',
    webhookPort: 3000,
    bearerToken: process.env.X_BEARER_TOKEN,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessTokenSecret: process.env.X_ACCESS_TOKEN_SECRET,
  };

  beforeAll(() => {
    if (shouldRunLiveTests && !hasCredentials) {
      throw new Error(
        'Missing X API credentials. Set X_API_KEY, X_API_SECRET, and either X_BEARER_TOKEN or both X_ACCESS_TOKEN and X_ACCESS_TOKEN_SECRET environment variables.'
      );
    }
  });

  beforeEach(() => {
    if (shouldRunLiveTests && hasCredentials) {
      service = new TwitterService(config);
      // Initialize the test client with the most specific credentials available
      if (process.env.X_ACCESS_TOKEN && process.env.X_ACCESS_TOKEN_SECRET) {
        twitterClient = new TwitterApi({
          appKey: config.apiKey,
          appSecret: config.apiSecret,
          accessToken: config.accessToken!,
          accessSecret: config.accessTokenSecret!,
        });
      } else {
        twitterClient = new TwitterApi(config.bearerToken!);
      }
    }
  });

  afterEach(async () => {
    // Cleanup: Stop the service after each test
    if (service) {
      await service.stop();
    }
  });

  // Helper function to create a test tweet
  const createTestTweet = async (content: string): Promise<string> => {
    const tweet = await twitterClient.v2.tweet(content);
    return tweet.data.id;
  };

  // Helper function to delete a test tweet
  const deleteTestTweet = async (tweetId: string): Promise<void> => {
    try {
      await twitterClient.v2.deleteTweet(tweetId);
    } catch (error) {
      console.warn(`Failed to delete test tweet ${tweetId}:`, error);
    }
  };

  describe('Live API Tests', () => {
    // Skip all tests if we're not running live tests
    (shouldRunLiveTests && hasCredentials ? describe : describe.skip)('API Integration', () => {
      describe('Tweet Interactions', () => {
        it('should correctly process a new mention and respond to it', async () => {
          const testTweetId = await createTestTweet('Test mention tweet');
          
          try {
            return new Promise<void>((resolve) => {
              service.on('newMention', async (mention: MentionEvent) => {
                expect(mention).toBeDefined();
                expect(mention.tweetId).toBe(testTweetId);
                
                // Test replying to the tweet
                await service['replyToTweet'](mention.tweetId, 'Test reply');
                
                // Verify the reply
                const timeline = await twitterClient.v2.userTimeline(mention.userId, {
                  expansions: ['referenced_tweets.id'] as TTweetv2Expansion[],
                });

                const reply = timeline.tweets.find((t: TweetV2) =>
                  t.referenced_tweets?.some((ref: ReferencedTweetV2) =>
                    ref.type === 'replied_to' && ref.id === testTweetId
                  )
                );
                
                expect(reply).toBeDefined();
                expect(reply?.text).toBe('Test reply');
                
                resolve();
              });
            });
          } finally {
            // Cleanup
            await deleteTestTweet(testTweetId);
          }
        }, 30000); // Increase timeout for API calls

        it('should handle rate limits gracefully', async () => {
          const tweets: string[] = [];
          
          try {
            // Create multiple tweets rapidly to trigger rate limit
            for (let i = 0; i < 5; i++) {
              const tweetId = await createTestTweet(`Rate limit test tweet ${i}`);
              tweets.push(tweetId);
            }
            
            let rateLimitWarningReceived = false;
            service.on('rateLimitWarning', () => {
              rateLimitWarningReceived = true;
            });
            
            // Try to reply to all tweets rapidly
            await Promise.all(
              tweets.map(tweetId => 
                service['replyToTweet'](tweetId, 'Test reply')
              )
            );
            
            expect(rateLimitWarningReceived).toBe(true);
          } finally {
            // Cleanup
            await Promise.all(tweets.map(deleteTestTweet));
          }
        }, 60000); // Increase timeout for rate limit test
      });

      describe('Thread Management', () => {
        it('should maintain thread history across multiple interactions', async () => {
          const threadId = 'test-thread-' + Date.now();
          const messages = Array.from({ length: 60 }, (_, i) => ({
            senderId: 'test-user',
            timestamp: Date.now() + i,
            content: `Message ${i}`,
          }));
          
          // Add messages to the thread
          for (const msg of messages) {
            service['addMessageToThread'](threadId, msg);
          }
          
          // Get thread context
          const context = service['getThreadContext'](threadId);
          
          // Verify thread history limit is respected
          expect(context.history).toHaveLength(50);
          
          // Verify we have the most recent messages
          const lastMessage = messages[messages.length - 1];
          expect(context.history[context.history.length - 1]).toEqual(lastMessage);
        });
      });
    });
  });

  describe('Webhook Error Handling', () => {
    it('should handle malformed webhook payload', async () => {
      const service = new TwitterService(config);
      await service.start();

      // Create a test server to send requests
      const testApp = express();
      testApp.use(express.json());
      const testPort = 3001;

      let testServer: Server | undefined;
      try {
        testServer = await new Promise<Server>((resolve, reject) => {
          let server: Server;
          server = testApp.listen(testPort, () => resolve(server));
          server.on('error', reject);
        });

        // Test cases for different types of invalid data
        const testCases = [
          {
            name: 'malformed JSON',
            data: 'invalid json',
            expectedStatus: 400
          },
          {
            name: 'missing required fields',
            data: { some: 'data' },
            expectedStatus: 400
          },
          {
            name: 'invalid event type',
            data: {
              for_user_id: '123',
              unknown_event: []
            },
            expectedStatus: 400
          }
        ];

        // Wait for the service to be ready
        await new Promise(resolve => setTimeout(resolve, 1000));

        for (const testCase of testCases) {
          try {
            const response = await axios.post(
              `http://localhost:${config.webhookPort}/webhook`,
              testCase.data,
              {
                headers: {
                  'Content-Type': 'application/json'
                },
                validateStatus: () => true, // Don't throw on error status
                timeout: 5000 // Add timeout
              }
            );

            expect(response.status).toBe(testCase.expectedStatus);
          } catch (error) {
            console.error(`Failed to test case ${testCase.name}:`, error);
            throw error;
          }
        }

        // Test missing signature
        try {
          const response = await axios.post(
            `http://localhost:${config.webhookPort}/webhook`,
            { valid: 'data' },
            {
              headers: {
                'Content-Type': 'application/json'
              },
              validateStatus: () => true,
              timeout: 5000
            }
          );
          expect(response.status).toBe(401);
        } catch (error) {
          console.error('Failed to test missing signature:', error);
          throw error;
        }

        // Test invalid signature
        try {
          const response2 = await axios.post(
            `http://localhost:${config.webhookPort}/webhook`,
            { valid: 'data' },
            {
              headers: {
                'Content-Type': 'application/json',
                'x-twitter-webhooks-signature': 'invalid'
              },
              validateStatus: () => true,
              timeout: 5000
            }
          );
          expect(response2.status).toBe(401);
        } catch (error) {
          console.error('Failed to test invalid signature:', error);
          throw error;
        }

      } finally {
        // Cleanup
        if (testServer) {
          await new Promise<void>((resolve) => {
            testServer!.close(() => resolve());
          });
        }
        await service.stop();
      }
    }, 30000);
  });
});

================
File: src/index.ts
================
import { TwitterServiceConfig, MentionEvent, Message, ThreadContext, RateLimitEvent, twitterWebhookSchema } from "./types";
import winston from "winston";
import express, { Express, Request, Response } from "express";
import { Server } from "http";
import { EventEmitter } from "events";
import { TwitterApi } from "twitter-api-v2";

/**
 * Service for handling Twitter interactions including webhooks and mentions
 */
export class TwitterService {
  private config: TwitterServiceConfig;
  private logger: winston.Logger;
  private app: Express;
  private emitter: EventEmitter;
  private twitterClient: TwitterApi;
  private threads: Map<string, ThreadContext>;
  private server?: Server;

  public on: (event: string | symbol, listener: (...args: any[]) => void) => EventEmitter;
  public emit: (event: string | symbol, ...args: any[]) => boolean;

  /**
   * Creates a new instance of TwitterService
   * @param config - Configuration options for the service
   */
  constructor(config: TwitterServiceConfig) {
    this.config = {
      ...config,
      threadHistoryLimit: config.threadHistoryLimit ?? 50,
    };
    this.threads = new Map();
    this.emitter = new EventEmitter();
    this.app = express();

    // Bind event emitter methods
    this.on = this.emitter.on.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);

    // Initialize logger with timestamp
    this.logger = winston.createLogger({
      level: "info",
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(({ level, message, timestamp, ...meta }) => {
          return `${timestamp} [${level}]: ${message} ${
            Object.keys(meta).length ? JSON.stringify(meta) : ""
          }`;
        })
      ),
      transports: [new winston.transports.Console()],
    });

    // Initialize Twitter client with the most specific credentials available
    if (config.accessToken && config.accessTokenSecret) {
      // Use user-specific credentials if available
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
        accessToken: config.accessToken,
        accessSecret: config.accessTokenSecret,
      });
    } else if (config.bearerToken) {
      // Fall back to bearer token if available
      this.twitterClient = new TwitterApi(config.bearerToken);
    } else {
      // Fall back to app-only credentials
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
      });
    }
  }

  /**
   * Starts the Twitter service and webhook server
   */
  public async start() {
    try {
      this.app.use(express.json());
      this.app.post("/webhook", this.webhook.bind(this));

      const server = this.app.listen(this.config.webhookPort, () => {
        this.logger.info(`Server is running on port ${this.config.webhookPort}`);
      });

      server.on("error", (error) => {
        this.logger.error("Server error occurred", { error });
        this.emit("serverError", error);
      });

      // Store server instance for cleanup
      this.server = server;

      this.logger.info("Twitter service started");
    } catch (error) {
      this.logger.error("Failed to start Twitter service", { error });
      throw error;
    }
  }

  /**
   * Stops the Twitter service and cleans up resources
   */
  public async stop() {
    try {
      if (this.server) {
        await new Promise<void>((resolve, reject) => {
          this.server!.close((err: Error | undefined) => {
            if (err) reject(err);
            else resolve();
          });
        });
        this.server = undefined;
      }

      // Clear all event listeners
      this.emitter.removeAllListeners();
      
      // Clear thread history
      this.threads.clear();

      this.logger.info("Twitter service stopped");
    } catch (error) {
      this.logger.error("Failed to stop Twitter service", { error });
      throw error;
    }
  }

  /**
   * Handles incoming webhook requests
   */
  private async webhook(req: Request, res: Response) {
    try {
      res.status(200).send("OK");
      await this.handleMention(req.body);
    } catch (error) {
      this.logger.error("Error processing webhook", { error, body: req.body });
      // We've already sent 200 OK to Twitter, but we'll emit an error event
      this.emit("webhookError", { error, body: req.body });
    }
  }

  /**
   * Processes mention events from the webhook
   */
  private async handleMention(mention: unknown) {
    this.logger.info("Received webhook", mention);

    const result = twitterWebhookSchema.safeParse(mention);

    if (!result.success) {
      this.logger.warn("Invalid mention format", {
        mention,
        error: result.error.format(),
      });
      this.emit("invalidMention", { mention, error: result.error });
      return;
    }

    const tweet = result.data.tweet;
    if (!tweet) {
      this.logger.warn("No tweet data in mention", { mention });
      return;
    }

    this.logger.info("Valid mention", {
      text: tweet.text,
      id: tweet.id,
    });

    const mentionEvent: MentionEvent = {
      message: tweet.text,
      threadId: tweet.conversation_id,
      userId: tweet.author_id,
      tweetId: tweet.id,
    };

    // Add message to thread context
    this.addMessageToThread(mentionEvent.threadId, {
      senderId: mentionEvent.userId,
      timestamp: Date.now(),
      content: mentionEvent.message,
    });

    this.emit("newMention", mentionEvent);
  }

  /**
   * Replies to a tweet with the given message
   */
  private async replyToTweet(tweetId: string, message: string) {
    try {
      const response = await this.twitterClient.v2.reply(message, tweetId);
      this.logger.info("Successfully responded to tweet", {
        tweetId,
        message,
        response,
      });
      return response;
    } catch (error: any) {
      if (error?.rateLimitError) {
        const rateLimitEvent: RateLimitEvent = {
          tweetId,
          message,
          error,
        };
        this.logger.warn("Rate limited when attempting to respond to tweet", rateLimitEvent);
        this.emit("rateLimitWarning", rateLimitEvent);
      } else {
        this.logger.error("Failed to respond to tweet", {
          tweetId,
          message,
          error,
        });
        this.emit("tweetError", { tweetId, message, error });
      }
      throw error;
    }
  }

  /**
   * Gets the context for a thread, creating it if it doesn't exist
   */
  private getThreadContext(threadId: string): ThreadContext {
    if (this.threads.has(threadId)) {
      return this.threads.get(threadId)!;
    } else {
      const newThread = { threadId: threadId, history: [] };
      this.threads.set(threadId, newThread);
      return newThread;
    }
  }

  /**
   * Adds a message to a thread's history, respecting the history limit if set
   */
  private addMessageToThread(threadId: string, message: Message) {
    const threadContext = this.getThreadContext(threadId);
    threadContext.history.push(message);

    // Apply history limit if configured
    if (this.config.threadHistoryLimit && threadContext.history.length > this.config.threadHistoryLimit) {
      threadContext.history = threadContext.history.slice(-this.config.threadHistoryLimit);
    }
  }
}

================
File: src/types.ts
================
import { z } from 'zod';

/**
 * Configuration options for the Twitter service
 */
export interface TwitterServiceConfig {
  /** Twitter API Key */
  apiKey: string;
  /** Twitter API Secret */
  apiSecret: string;
  /** Port number for the webhook server */
  webhookPort: number;
  /** Optional bearer token for authentication */
  bearerToken?: string;
  /** Optional access token for user-specific actions */
  accessToken?: string;
  /** Optional access token secret for user-specific actions */
  accessTokenSecret?: string;
  /** Maximum number of messages to keep in thread history */
  threadHistoryLimit?: number;
}

/**
 * Event emitted when a new mention is received
 */
export interface MentionEvent {
  /** ID of the conversation thread */
  threadId: string;
  /** ID of the user who created the mention */
  userId: string;
  /** Content of the mention */
  message: string;
  /** ID of the tweet */
  tweetId: string;
}

/**
 * Represents a message in a thread
 */
export interface Message {
  /** ID of the user who sent the message */
  senderId: string;
  /** Unix timestamp of when the message was sent */
  timestamp: number;
  /** Content of the message */
  content: string;
}

/**
 * Context for a conversation thread
 */
export interface ThreadContext {
  /** ID of the thread */
  threadId: string;
  /** History of messages in the thread */
  history: Message[];
}

/**
 * Rate limit error event
 */
export interface RateLimitEvent {
  /** ID of the tweet that triggered the rate limit */
  tweetId: string;
  /** Message that was attempted to be sent */
  message: string;
  /** Error details from Twitter API */
  error: any;
}

/**
 * Twitter entity mention
 */
const twitterMentionSchema = z.object({
  username: z.string(),
  id: z.string(),
});

/**
 * Twitter entities object
 */
const twitterEntitiesSchema = z.object({
  mentions: z.array(twitterMentionSchema).optional(),
});

/**
 * Referenced tweet object
 */
const referencedTweetSchema = z.object({
  type: z.string(),
  id: z.string(),
});

/**
 * Tweet object schema
 */
const tweetSchema = z.object({
  text: z.string(),
  id: z.string(),
  conversation_id: z.string(),
  author_id: z.string(),
  created_at: z.string().optional(),
  in_reply_to_user_id: z.string().optional(),
  referenced_tweets: z.array(referencedTweetSchema).optional(),
  entities: twitterEntitiesSchema.optional(),
});

/**
 * Direct message data schema
 */
const directMessageDataSchema = z.object({
  text: z.string(),
  entities: z.record(z.any()).optional(),
});

/**
 * Direct message create schema
 */
const directMessageCreateSchema = z.object({
  message_data: directMessageDataSchema,
  sender_id: z.string(),
  target: z.object({
    recipient_id: z.string(),
  }).optional(),
});

/**
 * Direct message event schema
 */
const directMessageEventSchema = z.object({
  type: z.string(),
  id: z.string(),
  message_create: directMessageCreateSchema,
});

/**
 * Zod schema for validating Twitter webhook payloads
 */
export const twitterWebhookSchema = z.object({
  tweet: tweetSchema.optional(),
  direct_message_events: z.array(directMessageEventSchema).optional(),
});

================
File: .env.example
================
# X (Twitter) API Credentials
# Get these from the X Developer Portal (https://developer.twitter.com/en/portal/dashboard)
X_API_KEY=
X_API_SECRET=
X_BEARER_TOKEN=
X_ACCESS_TOKEN=
X_ACCESS_TOKEN_SECRET=
X_CLIENT_ID=
X_CLIENT_SECRET=

# Test Control
# Set to true to enable live API tests locally
RUN_LIVE_TESTS=false

# Optional: Test Account Information
# The X account ID that will be used for testing
# TEST_ACCOUNT_ID=
# The X username that will be used for testing
# TEST_ACCOUNT_USERNAME=

================
File: .eslintrc.json
================
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }]
  }
}

================
File: .gitignore
================
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
build/

# Environment variables
.env
.env.local
.env.*.local

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Logs
logs/
*.log

# Test coverage
coverage/

================
File: .prettierrc
================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: ['/node_modules/', '/__tests__/'],
};

================
File: package.json
================
{
  "name": "@dao-bot/twitter-service",
  "version": "1.0.0",
  "description": "Twitter service for DAO Bot",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "prepublishOnly": "npm run build",
    "dev": "tsc -w",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepare": "npm run build"
  },
  "keywords": [
    "twitter",
    "dao",
    "bot"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "express": "^4.21.2",
    "twitter-api-v2": "^1.19.0",
    "winston": "^3.17.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/axios": "^0.9.36",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.11",
    "@types/node": "^22.10.5",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "axios": "^1.7.9",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "jest": "^29.7.0",
    "prettier": "^3.2.2",
    "ts-jest": "^29.1.1",
    "typescript": "^5.7.2"
  }
}

================
File: README.md
================
# @dao-bot/twitter-service

A Twitter service for DAO Bot that handles Twitter API interactions, webhook processing, and thread context management.

## Installation

```bash
npm install @dao-bot/twitter-service
```

## Setup

1. Create a Twitter Developer Account and set up a Project
   - Go to [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard)
   - Create a new Project and App
   - Get your API Key and API Secret
   - Set up OAuth 2.0 credentials
   - (Optional) Generate a Bearer Token

2. Configure your environment
   - Set up a webhook endpoint that's publicly accessible
   - Ensure your server can receive POST requests at your webhook URL

## Usage

```typescript
import { TwitterService } from '@dao-bot/twitter-service';

// Initialize the service
const twitterService = new TwitterService({
  apiKey: 'your_api_key',
  apiSecret: 'your_api_secret',
  webhookPort: 3000,
  // Optional: bearerToken: 'your_bearer_token'
});

// Handle new mentions
twitterService.on('newMention', async (mentionEvent) => {
  console.log('New mention:', mentionEvent);
  // Handle the mention event
  // mentionEvent contains:
  // - threadId: string
  // - userId: string
  // - message: string
  // - tweetId: string
});

// Start the service
await twitterService.start();
```

## Features

- Webhook endpoint for receiving Twitter events
- Event-based architecture for handling mentions
- Thread context management
- Rate limit handling
- Structured logging
- TypeScript support

## Types

### TwitterServiceConfig
```typescript
interface TwitterServiceConfig {
  apiKey: string;
  apiSecret: string;
  webhookPort: number;
  bearerToken?: string;
}
```

### MentionEvent
```typescript
interface MentionEvent {
  threadId: string;
  userId: string;
  message: string;
  tweetId: string;
}
```

### Message
```typescript
interface Message {
  senderId: string;
  timestamp: number;
  content: string;
}
```

### ThreadContext
```typescript
interface ThreadContext {
  threadId: string;
  history: Message[];
}
```

## Development

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Start in development mode
npm run dev

# Build and start
npm start
```

## License

ISC

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "outDir": "./dist",
    "sourceMap": true,
    "moduleResolution": "node",
    "declaration": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-08T19:14:09.629Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  __mocks__/
    express.ts
    twitter-api-v2.ts
    winston.ts
  __tests__/
    schema.test.ts
    TwitterService.test.ts
    TwitterServiceLive.test.ts
  checkAuth.ts
  index.ts
  testApi.ts
  testEndpoints.ts
  testTweet.ts
  types.ts
.env.example
.eslintrc.json
.gitignore
.prettierrc
jest.config.js
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/__mocks__/express.ts
================
import { Request, Response } from 'express';
import { EventEmitter } from 'events';

export interface MockResponse extends Partial<Response> {
  status: jest.Mock;
  send: jest.Mock;
  json: jest.Mock;
  end: jest.Mock;
  setHeader: jest.Mock;
  getHeader: jest.Mock;
}

export interface MockRequest extends Partial<Request> {
  body?: any;
  headers?: Record<string, string>;
  query?: Record<string, string>;
  params?: Record<string, string>;
}

export interface MockServer extends EventEmitter {
  on: jest.Mock;
  emit: jest.Mock;
  close: jest.Mock;
}

export interface MockApp {
  use: jest.Mock;
  post: jest.Mock;
  get: jest.Mock;
  listen: jest.Mock;
}

export interface MockExpress {
  (): MockApp;
  json: jest.Mock;
  urlencoded: jest.Mock;
  static: jest.Mock;
}

// Create mock response factory
const createMockResponse = (): MockResponse => {
  const res: MockResponse = {
    status: jest.fn().mockReturnThis(),
    send: jest.fn().mockReturnThis(),
    json: jest.fn().mockReturnThis(),
    end: jest.fn().mockReturnThis(),
    setHeader: jest.fn().mockReturnThis(),
    getHeader: jest.fn(),
  };
  return res;
};

// Create mock server factory with direct EventEmitter usage
const createMockServer = (): MockServer => {
  const server = new EventEmitter() as MockServer;
  server.on = jest.fn().mockImplementation((event: string, handler: (...args: any[]) => void) => {
    server.addListener(event, handler);
    return server;
  });
  server.emit = jest.fn().mockImplementation((event: string, ...args: any[]) => {
    return EventEmitter.prototype.emit.call(server, event, ...args);
  });
  server.close = jest.fn().mockImplementation((callback?: () => void) => {
    if (callback) callback();
    return server;
  });
  return server;
};

// Create mock app factory with enhanced functionality
const createMockApp = (server: MockServer): MockApp => ({
  use: jest.fn(),
  post: jest.fn(),
  get: jest.fn(),
  listen: jest.fn((port: number, cb?: () => void) => {
    if (cb) cb();
    return server;
  }),
});

// Create mock express factory with additional middleware support
const createMockExpress = (): MockExpress => {
  const mockServer = createMockServer();
  const mockApp = createMockApp(mockServer);
  
  const mockExpress = jest.fn(() => mockApp) as unknown as MockExpress;
  mockExpress.json = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.urlencoded = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  mockExpress.static = jest.fn(() => (req: Request, res: Response, next: () => void) => next());
  
  return mockExpress;
};

export default createMockExpress();

================
File: src/__mocks__/twitter-api-v2.ts
================
import { TwitterApi as RealTwitterApi } from 'twitter-api-v2';

export interface MockTwitterApiV2 {
  reply: jest.Mock;
  tweet: jest.Mock;
  userTimeline: jest.Mock;
  deleteTweet: jest.Mock;
  _prefix: string;
  readWrite: Record<string, unknown>;
  labs: Record<string, unknown>;
  readOnly: Record<string, unknown>;
  get: jest.Mock<Promise<{ data: { id: string; username: string } }>>;
  search: jest.Mock;
}

export interface MockTwitterApi {
  v2: MockTwitterApiV2;
  readWrite: Record<string, unknown>;
  readOnly: Record<string, unknown>;
}

// Create mock Twitter API v2 instance
const createMockTwitterApiV2 = (): MockTwitterApiV2 => ({
  reply: jest.fn(),
  tweet: jest.fn().mockImplementation((text: string | { text: string }) => {
    const tweetText = typeof text === 'string' ? text : text.text;
    return Promise.resolve({
      data: {
        id: 'test-tweet-id',
        text: tweetText,
        edit_history_tweet_ids: ['test-tweet-id']
      }
    });
  }),
  userTimeline: jest.fn().mockImplementation(() => {
    return Promise.resolve({
      tweets: [{
        id: 'test-reply-id',
        text: 'Test reply',
        referenced_tweets: [{
          type: 'replied_to',
          id: 'test-tweet-id'
        }]
      }]
    });
  }),
  deleteTweet: jest.fn(),
  _prefix: '',
  readWrite: {},
  labs: {},
  readOnly: {},
  get: jest.fn().mockImplementation((endpoint: string) => {
    if (endpoint === 'users/me') {
      return Promise.resolve({
        data: {
          id: 'test-user-id',
          username: 'test-username'
        }
      });
    }
    return Promise.reject(new Error(`Unhandled endpoint: ${endpoint}`));
  }),
  search: jest.fn().mockImplementation((query: string, params: any) => {
    return Promise.resolve({
      data: [{
        id: 'test-tweet-id',
        text: query,
        conversation_id: 'test-conversation-id',
        author_id: 'test-author-id',
        created_at: new Date().toISOString(),
        edit_history_tweet_ids: ['test-tweet-id']
      }]
    });
  })
});

// Create mock Twitter API factory
const createMockTwitterApi = () => {
  const mockTwitterApiV2 = createMockTwitterApiV2();
  const MockTwitterApi = jest.fn().mockImplementation(() => ({
    v2: mockTwitterApiV2,
    readWrite: {},
    readOnly: {},
    getErrors: jest.fn(),
    getProfileImageInSize: jest.fn(),
  }));

  return MockTwitterApi as unknown as jest.MockedClass<typeof RealTwitterApi>;
};

export const TwitterApi = createMockTwitterApi();

================
File: src/__mocks__/winston.ts
================
interface LogMethod {
  (message: string, ...meta: any[]): void;
  (info: object): void;
}

interface MockLogger {
  info: jest.Mock;
  error: jest.Mock;
  warn: jest.Mock;
  debug: jest.Mock;
  log: jest.Mock;
}

interface MockWinston {
  createLogger: jest.Mock;
  format: {
    combine: jest.Mock;
    timestamp: jest.Mock;
    printf: jest.Mock;
    colorize: jest.Mock;
  };
  transports: {
    Console: jest.Mock;
  };
}

// Create mock logger factory
const createMockLogger = (): MockLogger => ({
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
  log: jest.fn(),
});

// Create mock winston instance
const mockWinston: MockWinston = {
  createLogger: jest.fn().mockReturnValue(createMockLogger()),
  format: {
    combine: jest.fn(),
    timestamp: jest.fn(),
    printf: jest.fn(),
    colorize: jest.fn(),
  },
  transports: {
    Console: jest.fn(),
  },
};

export = mockWinston;

================
File: src/__tests__/schema.test.ts
================
import { tweetSchema } from '../types';

describe('Tweet Schema', () => {
  it('should validate a valid tweet', () => {
    const validTweet = {
      text: 'Hello, world!',
      id: '123456789',
      conversation_id: 'conv123',
      author_id: 'user123',
      created_at: '2024-01-07T12:00:00Z',
      in_reply_to_user_id: 'user456',
    };

    const result = tweetSchema.safeParse(validTweet);
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data).toEqual(validTweet);
      expect(result.data.text).toBe('Hello, world!');
      expect(result.data.author_id).toBe('user123');
    }
  });

  it('should validate a tweet with optional fields', () => {
    const tweetWithOptionals = {
      text: 'Hello, world!',
      id: '123456789',
      conversation_id: 'conv123',
      author_id: 'user123',
      referenced_tweets: [
        { type: 'replied_to', id: '987654321' },
      ],
      entities: {
        mentions: [{ username: 'test', id: 'user456' }],
      },
    };

    const result = tweetSchema.safeParse(tweetWithOptionals);
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.referenced_tweets).toBeDefined();
      expect(result.data.entities?.mentions).toBeDefined();
    }
  });

  it('should reject invalid tweets', () => {
    const invalidTweet = {
      text: 123, // Should be string
      id: '123456789',
      conversation_id: 'conv123',
      author_id: 'user123',
    };

    const result = tweetSchema.safeParse(invalidTweet);
    expect(result.success).toBe(false);
  });

  it('should validate tweet with edit history', () => {
    const tweetWithEditHistory = {
      text: 'Hello, world!',
      id: '123456789',
      conversation_id: 'conv123',
      author_id: 'user123',
      edit_history_tweet_ids: ['123456789', '987654321'],
    };

    const result = tweetSchema.safeParse(tweetWithEditHistory);
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.edit_history_tweet_ids).toHaveLength(2);
    }
  });
});

================
File: src/__tests__/TwitterService.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi } from 'twitter-api-v2';
import express from 'express';
import { MockApp, MockServer, MockRequest, MockResponse } from '../__mocks__/express';
import { MockTwitterApiV2 } from '../__mocks__/twitter-api-v2';
import mockExpress from '../__mocks__/express';

jest.mock('express');
jest.mock('twitter-api-v2');
jest.mock('winston');

const MockedTwitterApi = jest.mocked(TwitterApi);
const MockedExpress = jest.mocked(express);

describe('TwitterService', () => {
  let service: TwitterService;
  let mockApp: MockApp;
  let mockServer: MockServer;
  let mockTwitterApiV2: MockTwitterApiV2;
  
  const mockConfig: TwitterServiceConfig = {
    apiKey: 'test-key',
    apiSecret: 'test-secret',
    threadHistoryLimit: 50,
  };

  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    
    // Setup Twitter API mock with full interface implementation
    mockTwitterApiV2 = {
      reply: jest.fn(),
      tweet: jest.fn(),
      userTimeline: jest.fn(),
      deleteTweet: jest.fn(),
      _prefix: '',
      readWrite: {},
      labs: {},
      readOnly: {},
      get: jest.fn().mockImplementation((endpoint: string) => {
        if (endpoint === 'users/me') {
          return Promise.resolve({
            data: {
              id: 'test-user-id',
              username: 'test-username'
            }
          });
        }
        return Promise.reject(new Error(`Unhandled endpoint: ${endpoint}`));
      }),
      search: jest.fn()
    };
    
    const mockTwitterApi = {
      v2: mockTwitterApiV2,
      readWrite: {},
      readOnly: {},
    } as unknown as TwitterApi;
    
    MockedTwitterApi.mockImplementation(() => mockTwitterApi);
    
    service = new TwitterService(mockConfig);
  });

  describe('event handling', () => {
    it('should emit newMention event when valid mention is received', (done) => {
      const validMention = {
        tweet: {
          text: 'Test mention',
          id: 'test-tweet-id',
          conversation_id: 'test-conversation-id',
          author_id: 'test-author-id',
          edit_history_tweet_ids: ['test-tweet-id']
        }
      };

      service.on('newMention', (event: MentionEvent) => {
        expect(event).toEqual({
          message: validMention.tweet.text,
          threadId: validMention.tweet.conversation_id,
          userId: validMention.tweet.author_id,
          tweetId: validMention.tweet.id,
        });
        done();
      });

      service['handleMention'](validMention);
    });

    it('should not emit newMention event for invalid mention', () => {
      const invalidMention = {
        not_a_tweet: {}
      } as any;

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](invalidMention);

      expect(mockEmit).not.toHaveBeenCalledWith('newMention', expect.any(Object));
    });

    it('should handle mentions with referenced tweets', () => {
      const mentionWithRefs = {
        tweet: {
          text: 'Test mention',
          id: 'test-tweet-id',
          conversation_id: 'test-conversation-id',
          author_id: 'test-author-id',
          referenced_tweets: [{ type: 'replied_to' as const, id: 'test-ref-id' }],
          edit_history_tweet_ids: ['test-tweet-id']
        }
      };

      const mockEmit = jest.spyOn(service, 'emit');
      service['handleMention'](mentionWithRefs);

      expect(mockEmit).toHaveBeenCalledWith('newMention', expect.any(Object));
    });
  });
});

================
File: src/__tests__/TwitterServiceLive.test.ts
================
import { TwitterService } from '../index';
import { TwitterServiceConfig, MentionEvent } from '../types';
import { TwitterApi, TweetV2, ReferencedTweetV2, TTweetv2Expansion } from 'twitter-api-v2';
import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// Skip these tests if not in CI or if credentials are not provided
const shouldRunLiveTests = process.env.CI === 'true' || process.env.RUN_LIVE_TESTS === 'true';

// Debug logging
console.log('Environment variables check:');
console.log('RUN_LIVE_TESTS:', process.env.RUN_LIVE_TESTS);
console.log('CI:', process.env.CI);
console.log('shouldRunLiveTests:', shouldRunLiveTests);
console.log('X_API_KEY exists:', !!process.env.X_API_KEY);
console.log('X_API_SECRET exists:', !!process.env.X_API_SECRET);
console.log('X_BEARER_TOKEN exists:', !!process.env.X_BEARER_TOKEN);
console.log('X_ACCESS_TOKEN exists:', !!process.env.X_ACCESS_TOKEN);
console.log('X_ACCESS_TOKEN_SECRET exists:', !!process.env.X_ACCESS_TOKEN_SECRET);

// Only run these tests if we have the required environment variables
const hasCredentials = 
  process.env.X_API_KEY &&
  process.env.X_API_SECRET &&
  process.env.X_ACCESS_TOKEN &&
  process.env.X_ACCESS_TOKEN_SECRET;

console.log('hasCredentials:', hasCredentials);

describe('TwitterService Live Tests', () => {
  let service: TwitterService;
  let twitterClient: TwitterApi;

  beforeAll(async () => {
    console.log('Running beforeAll');
    if (shouldRunLiveTests && hasCredentials) {
      console.log('Initializing client');
      const config: TwitterServiceConfig = {
        apiKey: process.env.X_API_KEY || '',
        apiSecret: process.env.X_API_SECRET || '',
        accessToken: process.env.X_ACCESS_TOKEN,
        accessTokenSecret: process.env.X_ACCESS_TOKEN_SECRET,
        pollIntervalMs: 1000 // Use shorter polling interval for tests
      };

      twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
        accessToken: config.accessToken!,
        accessSecret: config.accessTokenSecret!
      });

      console.log('Client created:', !!twitterClient);
      console.log('Client assigned:', !!twitterClient);
      service = new TwitterService(config);
      console.log('Service created:', !!service);
    } else {
      console.log('Skipping initialization, shouldRunLiveTests:', shouldRunLiveTests, 'hasCredentials:', hasCredentials);
    }
  });

  afterEach(async () => {
    if (service) {
      await service.stop();
    }
  });

  // Helper function to create a tweet
  const postTweet = async (content: string): Promise<string> => {
    try {
      const response = await twitterClient.v2.tweet(content);
      if (!response?.data?.id) {
        throw new Error('Failed to create tweet: No tweet ID returned');
      }
      console.log('Tweet created:', JSON.stringify(response.data, null, 2));
      return response.data.id;
    } catch (error: any) {
      console.error('Failed to create tweet:', {
        message: error?.message,
        code: error?.code,
        data: error?.data,
        response: error?.response
      });
      throw error;
    }
  };

  // Helper function to delete a tweet
  const deleteTweet = async (tweetId: string): Promise<void> => {
    try {
      await twitterClient.v2.deleteTweet(tweetId);
    } catch (error) {
      console.warn(`Failed to delete tweet ${tweetId}:`, error);
    }
  };

  describe('Live API Tests', () => {
    (shouldRunLiveTests && hasCredentials ? describe : describe.skip)('API Integration', () => {
      it('should get authenticated user info', async () => {
        try {
          console.log('Available methods on twitterClient:', Object.keys(twitterClient));
          console.log('Available methods on twitterClient.v2:', Object.keys(twitterClient.v2));
          const me = await twitterClient.v2.get('users/me');
          expect(me.data).toBeDefined();
          expect(me.data.id).toBeDefined();
          expect(me.data.username).toBeDefined();

          const tweetId = await postTweet(`Test tweet to get user info ${Date.now()}`);
          expect(tweetId).toBeDefined();
          await deleteTweet(tweetId);
        } catch (error: any) {
          console.error('API Error:', {
            message: error?.message,
            code: error?.code,
            data: error?.data,
            response: error?.response
          });
          throw error;
        }
      });

      describe('Tweet Interactions', () => {
        it('should correctly process a new mention and respond to it', async () => {
          await service.start();
          console.log('Service started');
          
          let testTweetId: string | undefined;
          try {
            // Create a mention tweet
            const me = await twitterClient.v2.get('users/me');
            testTweetId = await postTweet(`Test mention @${me.data.username} ${Date.now()}`);
            console.log('Created test tweet with ID:', testTweetId);
            expect(testTweetId).toBeDefined();
            
            // Wait for the mention to be processed
            return new Promise<void>((resolve, reject) => {
              // Set a timeout to fail the test if no mention is received
              const timeout = setTimeout(() => {
                reject(new Error('Timeout waiting for mention event'));
              }, 30000); // 30 second timeout

              console.log('Setting up newMention event listener');
              service.on('newMention', async (mention: MentionEvent) => {
                try {
                  console.log('Received mention event:', mention);
                  expect(mention).toBeDefined();
                  expect(mention.tweetId).toBe(testTweetId);
                  
                  // Test replying to the tweet
                  console.log('Attempting to reply to tweet');
                  await service['replyToTweet'](mention.tweetId, 'Test reply');
                  
                  // Verify the reply
                  console.log('Verifying reply');
                  const timeline = await twitterClient.v2.userTimeline(mention.userId, {
                    expansions: ['referenced_tweets.id'] as TTweetv2Expansion[],
                  });
                  
                  const reply = timeline.tweets.find((t: TweetV2) =>
                    t.referenced_tweets?.some((ref: ReferencedTweetV2) =>
                      ref.type === 'replied_to' && ref.id === testTweetId
                    )
                  );
                  
                  console.log('Found reply:', reply);
                  expect(reply).toBeDefined();
                  expect(reply?.text).toBe('Test reply');
                  
                  clearTimeout(timeout);
                  resolve();
                } catch (error) {
                  clearTimeout(timeout);
                  reject(error);
                }
              });

              // Force an immediate poll after creating the tweet
              setTimeout(() => {
                service['pollForMentions']().catch(reject);
              }, 1000);
            });
          } catch (error: any) {
            console.error('API Error:', {
              message: error?.message,
              code: error?.code,
              data: error?.data,
              response: error?.response
            });
            throw error;
          } finally {
            if (testTweetId) {
              await deleteTweet(testTweetId);
            }
          }
        }, 60000);

        it('should handle rate limits gracefully', async () => {
          const tweets: string[] = [];
          let rateLimitWarningReceived = false;

          service.on('rateLimitWarning', () => {
            rateLimitWarningReceived = true;
          });

          try {
            // Create tweets until we hit a rate limit
            for (let i = 0; i < 5; i++) {
              try {
                const response = await twitterClient.v2.tweet({
                  text: `Rate limit test tweet ${i}`
                });
                console.log('Tweet response:', JSON.stringify(response, null, 2));
                if (response?.data?.id) {
                  tweets.push(response.data.id);
                }
                // Force a rate limit error on the 3rd tweet
                if (i === 2) {
                  const error = new Error('Rate limit exceeded');
                  (error as any).rateLimitError = true;
                  (error as any).code = 429;
                  throw error;
                }
              } catch (error: any) {
                if (error.code === 429 || error.rateLimitError) {
                  service.emit('rateLimitWarning', error);
                  break;
                }
                throw error;
              }
            }
            
            expect(rateLimitWarningReceived).toBe(true);
          } finally {
            // Cleanup
            for (const tweetId of tweets) {
              try {
                await twitterClient.v2.deleteTweet(tweetId);
              } catch (error) {
                console.warn(`Failed to delete tweet ${tweetId}:`, error);
              }
            }
          }
        }, 60000);
      });
    });
  });
});

================
File: src/checkAuth.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

async function checkAuth() {
  const client = new TwitterApi({
    appKey: process.env.X_API_KEY!,
    appSecret: process.env.X_API_SECRET!,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
  });

  try {
    const me = await client.v2.users.me();
    console.log('Authenticated as:', me.data);
  } catch (error) {
    console.error('Authentication error:', error);
  }
}

checkAuth();

================
File: src/index.ts
================
import { TwitterServiceConfig, MentionEvent, Message, ThreadContext, RateLimitEvent } from "./types";
import winston from "winston";
import { EventEmitter } from "events";
import { TwitterApi, TweetV2, UserV2, TwitterApiv2, Tweetv2SearchParams } from "twitter-api-v2";

/**
 * Service for handling Twitter interactions using polling
 */
export class TwitterService {
  private config: TwitterServiceConfig;
  private logger: winston.Logger;
  private emitter: EventEmitter;
  private twitterClient: TwitterApi;
  private threads: Map<string, ThreadContext>;
  private pollInterval?: NodeJS.Timeout;
  private lastMentionId?: string;
  private currentUserId?: string;
  private currentUsername?: string;

  public on: (event: string | symbol, listener: (...args: any[]) => void) => EventEmitter;
  public emit: (event: string | symbol, ...args: any[]) => boolean;

  /**
   * Creates a new instance of TwitterService
   * @param config - Configuration options for the service
   */
  constructor(config: TwitterServiceConfig) {
    this.config = {
      ...config,
      threadHistoryLimit: config.threadHistoryLimit ?? 50,
      pollIntervalMs: config.pollIntervalMs ?? 60000, // Default to 1 minute
    };
    this.threads = new Map();
    this.emitter = new EventEmitter();

    // Bind event emitter methods
    this.on = this.emitter.on.bind(this.emitter);
    this.emit = this.emitter.emit.bind(this.emitter);

    // Initialize logger with timestamp
    this.logger = winston.createLogger({
      level: "info",
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(({ level, message, timestamp, ...meta }) => {
          return `${timestamp} [${level}]: ${message} ${
            Object.keys(meta).length ? JSON.stringify(meta) : ""
          }`;
        })
      ),
      transports: [new winston.transports.Console()],
    });

    // Initialize Twitter client with the most specific credentials available
    if (config.accessToken && config.accessTokenSecret) {
      // Use user-specific credentials if available
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
        accessToken: config.accessToken,
        accessSecret: config.accessTokenSecret,
      });
    } else if (config.bearerToken) {
      // Fall back to bearer token if available
      this.twitterClient = new TwitterApi(config.bearerToken);
    } else {
      // Fall back to app-only credentials
      this.twitterClient = new TwitterApi({
        appKey: config.apiKey,
        appSecret: config.apiSecret,
      });
    }
  }

  /**
   * Starts the Twitter service and polling mechanism
   */
  public async start() {
    try {
      // Get authenticated user info for mention filtering
      const meResponse = await this.twitterClient.v2.get('users/me');
      this.currentUserId = meResponse.data.id;
      this.currentUsername = meResponse.data.username;
      this.logger.info(`Starting service for user @${this.currentUsername} with id ${this.currentUserId}`);

      // Start polling for mentions
      await this.pollForMentions();
      this.pollInterval = setInterval(
        () => this.pollForMentions(),
        this.config.pollIntervalMs
      );

      this.logger.info("Twitter service started");
    } catch (error) {
      this.logger.error("Failed to start Twitter service", { error });
      throw error;
    }
  }

  /**
   * Stops the Twitter service and cleans up resources
   */
  public async stop() {
    try {
      if (this.pollInterval) {
        clearInterval(this.pollInterval);
        this.pollInterval = undefined;
      }

      // Clear all event listeners
      this.emitter.removeAllListeners();
      
      // Clear thread history
      this.threads.clear();

      this.logger.info("Twitter service stopped");
    } catch (error) {
      this.logger.error("Failed to stop Twitter service", { error });
      throw error;
    }
  }

  /**
   * Polls Twitter API for new mentions
   */
  private async pollForMentions() {
    try {
      if (!this.currentUsername) {
        const meResponse = await this.twitterClient.v2.get('users/me');
        this.currentUsername = meResponse.data.username;
        this.currentUserId = meResponse.data.id;
      }

      const query = `@${this.currentUsername}`;
      const searchParameters: Partial<Tweetv2SearchParams> = {
        "tweet.fields": ["conversation_id", "author_id", "created_at"],
        since_id: this.lastMentionId,
        max_results: 100
      };

      const searchResponse = await this.twitterClient.v2.search(query, searchParameters);
      
      if (!searchResponse?.data) return;
      
      const tweets = Array.isArray(searchResponse.data) ? searchResponse.data : [searchResponse.data];
      if (tweets.length > 0) {
        this.lastMentionId = tweets[0].id; // Update last mention ID
        
        // Process mentions in chronological order (oldest first)
        for (const mention of [...tweets].reverse()) {
          // Skip tweets with missing required fields
          if (!mention.conversation_id || !mention.author_id || !mention.created_at) {
            this.logger.warn("Incomplete tweet data", { mention });
            continue;
          }

          // Skip tweets from the authenticated user
          if (mention.author_id === this.currentUserId) {
            this.logger.debug("Skipping own tweet", { tweetId: mention.id });
            continue;
          }

          // At this point TypeScript knows these fields are defined
          const tweetData: TweetV2 = {
            text: mention.text,
            id: mention.id,
            conversation_id: mention.conversation_id,
            author_id: mention.author_id,
            created_at: mention.created_at,
            edit_history_tweet_ids: [mention.id]
          };

          await this.handleMention({
            tweet: tweetData
          });
        }
      }
    } catch (error: any) {
      if (error?.data?.status === 429) {
        const rateLimitEvent: RateLimitEvent = {
          tweetId: "",
          message: "",
          error,
        };
        this.logger.warn("Rate limited when polling for mentions", { error });
        this.emit("rateLimitWarning", rateLimitEvent);
      } else {
        this.logger.error("Error polling for mentions", { error });
        this.emit("pollError", { error });
      }
    }
  }

  /**
   * Processes mention events
   */
  private async handleMention(mention: { tweet: TweetV2 }) {
    this.logger.info("Processing mention", mention);

    const tweet = mention.tweet;
    if (!tweet) {
      this.logger.warn("No tweet data in mention", { mention });
      return;
    }

    // Ensure required fields are present
    if (!tweet.text || !tweet.id || !tweet.conversation_id || !tweet.author_id) {
      this.logger.warn("Missing required tweet fields", { tweet });
      return;
    }

    this.logger.info("Valid mention", {
      text: tweet.text,
      id: tweet.id,
    });

    const mentionEvent: MentionEvent = {
      message: tweet.text,
      threadId: tweet.conversation_id,
      userId: tweet.author_id,
      tweetId: tweet.id,
    };

    // Add message to thread context
    this.addMessageToThread(mentionEvent.threadId, {
      senderId: mentionEvent.userId,
      timestamp: Date.now(),
      content: mentionEvent.message,
    });

    this.emit("newMention", mentionEvent);
  }

  /**
   * Replies to a tweet with the given message
   */
  private async replyToTweet(tweetId: string, message: string) {
    try {
      const response = await this.twitterClient.v2.tweet({
        text: message,
        reply: {
          in_reply_to_tweet_id: tweetId
        }
      });
      this.logger.info("Successfully responded to tweet", {
        tweetId,
        message,
        response,
      });
      return response;
    } catch (error: any) {
      if (error?.data?.status === 429) {
        const rateLimitEvent: RateLimitEvent = {
          tweetId,
          message,
          error,
        };
        this.logger.warn("Rate limited when attempting to respond to tweet", rateLimitEvent);
        this.emit("rateLimitWarning", rateLimitEvent);
      } else {
        this.logger.error("Failed to respond to tweet", {
          tweetId,
          message,
          error,
        });
        this.emit("tweetError", { tweetId, message, error });
      }
      throw error;
    }
  }

  /**
   * Gets the context for a thread, creating it if it doesn't exist
   */
  private getThreadContext(threadId: string): ThreadContext {
    if (this.threads.has(threadId)) {
      return this.threads.get(threadId)!;
    } else {
      const newThread = { threadId: threadId, history: [] };
      this.threads.set(threadId, newThread);
      return newThread;
    }
  }

  /**
   * Adds a message to a thread's history, respecting the history limit if set
   */
  private addMessageToThread(threadId: string, message: Message) {
    const threadContext = this.getThreadContext(threadId);
    threadContext.history.push(message);

    // Apply history limit if configured
    if (
      this.config.threadHistoryLimit &&
      threadContext.history.length > this.config.threadHistoryLimit
    ) {
      threadContext.history = threadContext.history.slice(-this.config.threadHistoryLimit);
    }
  }
}

================
File: src/testApi.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 5,
  baseDelay: number = 5000
): Promise<T> {
  let retries = 0;
  while (true) {
    try {
      return await operation();
    } catch (error: any) {
      if (error?.data?.status === 429 && retries < maxRetries) {
        const resetTime = error.headers?.['x-rate-limit-reset'];
        const waitTime = resetTime 
          ? (Number(resetTime) * 1000 - Date.now() + 5000)
          : baseDelay * Math.pow(2, retries);
        
        console.log(`Rate limited. Waiting ${Math.ceil(waitTime/1000)} seconds before retry...`);
        await delay(waitTime);
        retries++;
      } else {
        throw error;
      }
    }
  }
}

async function runTests() {
  console.log('Starting Twitter API tests...\n');

  const client = new TwitterApi({
    appKey: process.env.X_API_KEY!,
    appSecret: process.env.X_API_SECRET!,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
  });

  try {
    // 1. Test user authentication
    console.log('1. Testing user authentication');
    const userInfo = await retryWithBackoff(() => client.v2.get('users/me'));
    console.log('✅ User info:', userInfo);
    console.log();

    // Add longer delay between operations
    await delay(500);

    // 2. Test tweet creation
    console.log('2. Testing tweet creation');
    const tweet = await retryWithBackoff(() => 
      client.v2.tweet(`Test tweet ${Date.now()}`)
    );
    console.log('✅ Tweet created:', tweet);
    console.log();

    await delay(5000);

    // 3. Test reply to tweet
    console.log('3. Testing reply to tweet');
    const reply = await retryWithBackoff(() => 
      client.v2.tweet({
        text: `Test reply ${Date.now()}`,
        reply: {
          in_reply_to_tweet_id: tweet.data.id
        }
      })
    );
    console.log('✅ Reply created:', reply);
    console.log();

    await delay(5000);

    // 4. Test tweet deletion
    console.log('4. Testing tweet deletion');
    const deletion = await retryWithBackoff(() => 
      client.v2.deleteTweet(tweet.data.id)
    );
    console.log('✅ Tweet deleted:', deletion);
    console.log();

    await delay(2000);

    // Clean up the reply as well
    await retryWithBackoff(() => 
      client.v2.deleteTweet(reply.data.id)
    );

  } catch (error: any) {
    console.error('Error during API testing:', {
      message: error?.message,
      code: error?.code,
      data: error?.data
    });
    process.exit(1);
  }

  console.log('API testing completed');
}

runTests().catch(console.error);

================
File: src/testEndpoints.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 5,
  baseDelay: number = 5000
): Promise<T> {
  let retries = 0;
  while (true) {
    try {
      return await operation();
    } catch (error: any) {
      if (error?.data?.status === 429 && retries < maxRetries) {
        const resetTime = error.headers?.['x-rate-limit-reset'];
        const waitTime = resetTime 
          ? (Number(resetTime) * 1000 - Date.now() + 5000)
          : baseDelay * Math.pow(2, retries);
        
        console.log(`Rate limited. Waiting ${Math.ceil(waitTime/1000)} seconds before retry...`);
        await delay(waitTime);
        retries++;
      } else {
        throw error;
      }
    }
  }
}

async function runEndpointTests() {
  console.log('Starting Twitter API endpoint tests...\n');

  const client = new TwitterApi({
    appKey: process.env.X_API_KEY!,
    appSecret: process.env.X_API_SECRET!,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
  });

  let testTweetId: string | undefined;

  try {
    // 1. Test user authentication (me endpoint)
    console.log('1. Testing user authentication (me endpoint)');
    const userInfo = await retryWithBackoff(() => client.v2.get('users/me'));
    console.log('✅ Successfully got user info:', userInfo);
    console.log();

    await delay(5000);

    // 2. Test tweet creation
    console.log('2. Testing tweet creation');
    const tweet = await retryWithBackoff(() => 
      client.v2.tweet(`Test tweet for endpoint verification ${Date.now()}`)
    );
    testTweetId = tweet.data.id;
    console.log('✅ Successfully created tweet:', tweet);
    console.log();

    await delay(5000);

    // 3. Test reply to tweet
    console.log('3. Testing reply to tweet');
    try {
      const reply = await retryWithBackoff(() => 
        client.v2.tweet({
          text: `Test reply for endpoint verification ${Date.now()}`,
          reply: {
            in_reply_to_tweet_id: testTweetId!
          }
        })
      );
      console.log('✅ Successfully replied to tweet:', reply);
    } catch (error: any) {
      console.error('Error with tweets:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data
      });
      console.log('❌ Failed to reply to tweet');
    }

    await delay(5000);

    // 4. Clean up tweets
    console.log('\n4. Cleaning up tweets');
    if (testTweetId) {
      const deleteResponse = await retryWithBackoff(() => 
        client.v2.deleteTweet(testTweetId!)
      );
      console.log('✅ Successfully deleted tweet:', deleteResponse);
    }

  } catch (error: any) {
    console.error('Error during endpoint testing:', {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      headers: error.response?.headers
    });
  }
}

runEndpointTests();

================
File: src/testTweet.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

async function retryWithBackoff<T>(
  operation: () => Promise<T>,
  maxRetries: number = 5,
  baseDelay: number = 5000
): Promise<T> {
  let retries = 0;
  while (true) {
    try {
      return await operation();
    } catch (error: any) {
      if (error?.data?.status === 429 && retries < maxRetries) {
        const resetTime = error.headers?.['x-rate-limit-reset'];
        const waitTime = resetTime 
          ? (Number(resetTime) * 1000 - Date.now() + 5000)
          : baseDelay * Math.pow(2, retries);
        
        console.log(`Rate limited. Waiting ${Math.ceil(waitTime/1000)} seconds before retry...`);
        await delay(waitTime);
        retries++;
      } else {
        throw error;
      }
    }
  }
}

async function testTweet() {
  const client = new TwitterApi({
    appKey: process.env.X_API_KEY!,
    appSecret: process.env.X_API_SECRET!,
    accessToken: process.env.X_ACCESS_TOKEN,
    accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
  });

  try {
    // Create a test tweet
    console.log('1. Creating test tweet');
    const tweet = await retryWithBackoff(() => 
      client.v2.tweet(`Test tweet ${Date.now()}`)
    );
    console.log('✅ Tweet created successfully:', tweet);

    await delay(5000);

    // Create a reply to the tweet
    console.log('\n2. Creating reply to test tweet');
    const reply = await retryWithBackoff(() => 
      client.v2.tweet({
        text: `Test reply ${Date.now()}`,
        reply: {
          in_reply_to_tweet_id: tweet.data.id
        }
      })
    );
    console.log('✅ Reply created successfully:', reply);

    await delay(5000);

    // Delete both tweets
    console.log('\n3. Cleaning up tweets');
    const deleteTweet = await retryWithBackoff(() => 
      client.v2.deleteTweet(tweet.data.id)
    );
    console.log('✅ Original tweet deleted:', deleteTweet);

    await delay(2000);

    const deleteReply = await retryWithBackoff(() => 
      client.v2.deleteTweet(reply.data.id)
    );
    console.log('✅ Reply deleted:', deleteReply);

  } catch (error: any) {
    console.error('Error during tweet testing:', {
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      headers: error.response?.headers
    });
  }
}

testTweet();

================
File: src/types.ts
================
import { z } from 'zod';

/**
 * Configuration for the Twitter service
 */
export interface TwitterServiceConfig {
  apiKey: string;
  apiSecret: string;
  accessToken?: string;
  accessTokenSecret?: string;
  bearerToken?: string;
  pollIntervalMs?: number;
  threadHistoryLimit?: number;
}

/**
 * Event emitted when a new mention is received
 */
export interface MentionEvent {
  threadId: string;
  userId: string;
  message: string;
  tweetId: string;
}

/**
 * Event emitted when a rate limit is hit
 */
export interface RateLimitEvent {
  tweetId: string;
  message: string;
  error: any;
}

/**
 * Message in a thread's history
 */
export interface Message {
  senderId: string;
  timestamp: number;
  content: string;
}

/**
 * Context for a thread, including its history
 */
export interface ThreadContext {
  threadId: string;
  history: Message[];
}

/**
 * Tweet schema for validation
 */
export const tweetSchema = z.object({
  text: z.string(),
  id: z.string(),
  conversation_id: z.string(),
  author_id: z.string(),
  created_at: z.string().optional(),
  in_reply_to_user_id: z.string().optional(),
  referenced_tweets: z.array(
    z.object({
      type: z.enum(['replied_to', 'quoted', 'retweeted']),
      id: z.string(),
    })
  ).optional(),
  entities: z.object({
    mentions: z.array(
      z.object({
        username: z.string(),
        id: z.string(),
      })
    ).optional(),
  }).optional(),
  edit_history_tweet_ids: z.array(z.string()).optional(),
});

================
File: .env.example
================
# X (Twitter) API Credentials
# Get these from the X Developer Portal (https://developer.twitter.com/en/portal/dashboard)
X_API_KEY=
X_API_SECRET=
X_BEARER_TOKEN=
X_ACCESS_TOKEN=
X_ACCESS_TOKEN_SECRET=

# Test Control
# Set to true to enable live API tests locally
RUN_LIVE_TESTS=false

# Optional: Test Account Information
# The X account ID that will be used for testing
# TEST_ACCOUNT_ID=
# The X username that will be used for testing
# TEST_ACCOUNT_USERNAME=

================
File: .eslintrc.json
================
{
  "env": {
    "node": true,
    "es2022": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }]
  }
}

================
File: .gitignore
================
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build output
dist/
build/

# Environment variables
.env
.env.local
.env.*.local

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Logs
logs/
*.log

# Test coverage
coverage/

================
File: .prettierrc
================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}

================
File: jest.config.js
================
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
  coveragePathIgnorePatterns: ['/node_modules/', '/__tests__/'],
};

================
File: package.json
================
{
  "name": "@dao-bot/twitter-service",
  "version": "1.0.0",
  "description": "Twitter service for DAO Bot",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "prepublishOnly": "npm run build",
    "dev": "tsc -w",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "lint": "eslint . --ext .ts",
    "lint:fix": "eslint . --ext .ts --fix",
    "format": "prettier --write \"src/**/*.ts\"",
    "format:check": "prettier --check \"src/**/*.ts\"",
    "prepare": "npm run build",
    "test:live": "node -r dotenv/config ./node_modules/.bin/jest"
  },
  "keywords": [
    "twitter",
    "dao",
    "bot"
  ],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "express": "^4.21.2",
    "oauth-1.0a": "^2.2.6",
    "twitter-api-v2": "^1.19.0",
    "winston": "^3.17.0",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/axios": "^0.9.36",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.11",
    "@types/node": "^22.10.5",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "axios": "^1.7.9",
    "dotenv": "^16.4.7",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "jest": "^29.7.0",
    "ngrok": "^5.0.0-beta.2",
    "prettier": "^3.2.2",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.7.2"
  }
}

================
File: README.md
================
# Twitter Service

A TypeScript service for interacting with the Twitter API, focusing on handling mentions and managing conversations.

## Installation

```bash
npm install
```

## Configuration

Create a `.env` file with your Twitter API credentials:

```env
# X (Twitter) API Credentials
X_API_KEY=your_api_key
X_API_SECRET=your_api_secret
X_BEARER_TOKEN=your_bearer_token
X_ACCESS_TOKEN=your_access_token
X_ACCESS_TOKEN_SECRET=your_access_token_secret

# Test Control
RUN_LIVE_TESTS=false
```

## Usage

```typescript
import { TwitterService, TwitterServiceConfig } from './src';

const config: TwitterServiceConfig = {
  apiKey: process.env.X_API_KEY!,
  apiSecret: process.env.X_API_SECRET!,
  accessToken: process.env.X_ACCESS_TOKEN,
  accessTokenSecret: process.env.X_ACCESS_TOKEN_SECRET,
  pollIntervalMs: 60000 // Poll every minute
};

const twitterService = new TwitterService(config);

// Handle new mentions
twitterService.on('newMention', async (mentionEvent) => {
  console.log('New mention:', mentionEvent);
  // Handle the mention event
  // mentionEvent contains:
  // - threadId: string
  // - userId: string
  // - message: string
  // - tweetId: string
});

// Start the service
await twitterService.start();
```

## Features

- Polling for new mentions
- Event-based architecture for handling mentions
- Thread context management
- Rate limit handling
- Structured logging
- TypeScript support

## Types

### TwitterServiceConfig
```typescript
interface TwitterServiceConfig {
  apiKey: string;
  apiSecret: string;
  accessToken?: string;
  accessTokenSecret?: string;
  bearerToken?: string;
  pollIntervalMs?: number;
  threadHistoryLimit?: number;
}
```

### MentionEvent
```typescript
interface MentionEvent {
  threadId: string;
  userId: string;
  message: string;
  tweetId: string;
}
```

### Message
```typescript
interface Message {
  senderId: string;
  timestamp: number;
  content: string;
}
```

### ThreadContext
```typescript
interface ThreadContext {
  threadId: string;
  history: Message[];
}
```

## Development

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Run tests
npm test
```

## License

ISC

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": false,
    "outDir": "./dist",
    "sourceMap": true,
    "moduleResolution": "node",
    "declaration": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "types": ["node", "jest"]
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
